using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.XPath;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Schemer.Editors;
using Fuzzware.Schemer.AutoGenerated;

namespace Fuzzware.Schemer.Fuzzers.OccurrenceFuzzing
{
    /// <summary>
    /// Order fuzzing is for nodes whose particles are either of type xs:all or xs:choice with maxOccurs > 1 (and we have
    /// multiply examples to choose from).
    /// </summary>
    class OrderFuzzer : FuzzerBase, IChildNodesFuzzer
    {
        PreCompData oPreComp;
        ComplexTypeFuzzerConfig Config;
        IChildNodesEditor oChildNodesEditor;
        //List<XPathNavigator> oChildXPathNavs;
        List<XPathNavigator> oXPathNavReturnArray;
        //int LastNodeIndex = Int32.MinValue;
        XMLElementIdentifier NonSpecficId;
        int NumberOfChoices = 0;   // This is the maximum of the (maxOccurs - minOccurs) for all fuzzable nodes.  From this we
                                    // can calculate the number of possible permutations, so we don't fuzz the same
                                    // permutations 100s of times.
        

        public OrderFuzzer(ConfigData oConfigData, PreCompData oPreCompData, XMLElementIdentifier oElementId)
            : base(oConfigData, oPreCompData)
        {
            oPreComp = oPreCompData;
            Config = oConfigData.CTFConfig;
            NonSpecficId = oElementId;

            if (!Config.OrderFuzzingCountSpecified)
                return;

            Add("Order", FuzzOrder);
        }

        protected override int CountOfCurrentNodes
        {
            get
            {
                if (null != oChildNodesEditor)
                {
                    return oChildNodesEditor.NodeCount();
                }
                Log.Write(MethodBase.GetCurrentMethod(), "Unable to return CountOfCurrentNodes, oChildNodesEditor was null", Log.LogType.Error);
                return 0;
            }
        }

        public bool FuzzOrder(int FuzzIndex, int NodeIndex)
        {
            // Ignoring the all nodes index
            if (-1 == NodeIndex)
            {
                throw new SkipStateException();
            }

            // Check the FuzzIndex against the number of permutations to try
            if (FuzzIndex > (int)Config.OrderFuzzingCount)
                return false;

            // We want to get the specific ElementDBEntry for the node we are fuzzing so the min and max occurs are right
            XMLElementIdentifier Id = new XMLElementIdentifier(NonSpecficId.QualifiedName, NonSpecficId.SchemaType as XmlSchemaElement, oPreComp.SchemaSet,
                oChildNodesEditor.GetNodeInstance(NodeIndex).Particle.MinOccurs, oChildNodesEditor.GetNodeInstance(NodeIndex).Particle.MaxOccurs);
            ParticleDBEntry FuzzNodeParticleEntry = oPreComp.ObjectDB[Id] as ParticleDBEntry;

            oXPathNavReturnArray = new List<XPathNavigator>();

            CreateParticleInstance(FuzzNodeParticleEntry, oChildNodesEditor.GetNodeInstance(NodeIndex), FuzzIndex);

            if (0 == NumberOfChoices)
                return false;   // We did not come across any nodes that we could fuzz
            if (FuzzIndex > Perm(NumberOfChoices))
                return false;   // There are not enough permutations of choice options to satisfy this FuzzIndex

            oChildNodesEditor.SetNodeArray(oXPathNavReturnArray, NodeIndex);

            return true;
        }

        private int Perm(int n)
        {
            if (n < 1)
                return -2;
            if (n > 10)
                return Int32.MaxValue;
            int result = 1;
            for (int i = 2; i < n; i++)
                result *= i;
            return result;
        }

        private void CreateParticleInstance(ParticleDBEntry ParticleDBEntry, ParticleInstance oParticleInstance, int FuzzIndex)
        {
            // If we don't have any ParticleInstance's to use, we probably don't need to continue
            if (null == oParticleInstance)
                return;

            // Make a copy of the child instance list
            List<ParticleDBEntry> oChildParticleDBEntries = new List<ParticleDBEntry>(ParticleDBEntry.SubParticles);

            int InstancesFound = 0;                 // Keep track of how many child instances have been discovered so far

            // Go through all the sub-particles            
            for (int i = 0; i < oChildParticleDBEntries.Count; i++)
            {
                List<ParticleInstance> InstancesAtIndex = new List<ParticleInstance>();
                if (null != oParticleInstance)
                {
                    InstancesAtIndex = oParticleInstance.GetSubParticlesOfTypeFromIndex(oChildParticleDBEntries[i].Particle, InstancesFound);
                    InstancesFound += InstancesAtIndex.Count;
                }

                // If this particle is interesting to us
                if (CanFuzzOrder(oChildParticleDBEntries[i]))
                {
                    List<ParticleInstance> oRandomOrderInstancesAtIndex = new List<ParticleInstance>();
                    
                    Random oRanGen = new Random(FuzzIndex);

                    // Randomly order the Child Particles
                    while (InstancesAtIndex.Count > 0)
                    {
                        int PositionToAdd = oRanGen.Next(InstancesAtIndex.Count);

                        oRandomOrderInstancesAtIndex.Add(InstancesAtIndex[PositionToAdd]);

                        InstancesAtIndex.RemoveAt(PositionToAdd);
                    }
                    // InstancesAtIndex is what will be used below
                    InstancesAtIndex = oRandomOrderInstancesAtIndex;
                }

                // Get XPathNavs to the XmlSchemaElements/XmlSchemaGroups and recurse into XmlSchemaSequence/XmlSchemaChoice
                if (oChildParticleDBEntries[i] is ElementDBEntry)
                {
                    for (int j = 0; j < InstancesAtIndex.Count; j++)
                        oXPathNavReturnArray.AddRange(InstancesAtIndex[j].XPathNavs);
                }
                else
                {
                    // We need a ParticleInstance in order to recurse
                    //ParticleInstance SubInstance = null;
                    //if(InstancesAtIndex.Count > 0)
                    //    SubInstance = InstancesAtIndex[0];
                    //else if (null != oParticleInstance)
                    //{
                    //    List<ParticleInstance> AllInstances = oParticleInstance.GetAllSubParticlesOfType(oChildParticleDBEntries[i].Particle);
                    //    if(AllInstances.Count > 0)
                    //        SubInstance = AllInstances[0];
                    //}
                    for (int j = 0; j < InstancesAtIndex.Count; j++)
                    {
                        // Recurse
                        CreateParticleInstance(oChildParticleDBEntries[i], InstancesAtIndex[j], FuzzIndex);
                    }
                }
            }
        }

        /// <summary>
        /// Returns true if this is the sort of particle where we can change the order
        /// </summary>
        private bool CanFuzzOrder(ParticleDBEntry ParticleDBEntry)
        {
            // Is it a choice
            if (ParticleDBEntry.Particle is XmlSchemaChoice)
            {
                // Is maxOccurs greater than minOccurs and maxOccurs > 1
                int maxOccurs = (ParticleDBEntry.Particle.MaxOccursString == "unbounded") ? Int32.MaxValue : (int)ParticleDBEntry.Particle.MaxOccurs;
                if ((maxOccurs > 1) && (maxOccurs > (int)ParticleDBEntry.Particle.MinOccurs))
                {
                    if (NumberOfChoices < (maxOccurs - (int)ParticleDBEntry.Particle.MinOccurs))
                        NumberOfChoices = (maxOccurs - (int)ParticleDBEntry.Particle.MinOccurs);
                    return true;
                }
            }
            // Is it an all
            else if (ParticleDBEntry.Particle is XmlSchemaAll)
                return true;

            // We can't fuzz this particle
            return false;
        }

        #region IChildNodesFuzzer Members

        public override void Initialise()
        {
            base.Initialise();

            if (null == oChildNodesEditor)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Child Nodes Editor was null", Log.LogType.Error);
            }

            // Initialise the instances of the particles in the SchemerParticleDB
            oChildNodesEditor.Initialise();

        }

        public override void Restore()
        {
            oChildNodesEditor.RestoreChildNodes();
        }

        public Fuzzware.Schemer.Editors.IChildNodesEditor ChildNodesEditor
        {
            set { oChildNodesEditor = value; }
        }

        #endregion
    }
}
