using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Schemer.AutoGenerated;

namespace Fuzzware.Schemer.Fuzzers.BinaryFuzzing
{
    abstract class BinaryFuzzerBase : FuzzerBase, ITypeFuzzer
    {
        protected BinaryValueFuzzer ValueConfig;
        protected byte[][] FuzzingValues;              // The user provided byte values
        protected ValueRange BytesVR;
        protected int MaxFuzzIndex;
        protected int FuzzingValuesMinValueLength;     // The length of the shortest element in FuzzingValues

        public BinaryFuzzerBase(ConfigData oConfigData, PreCompData oPreCompData, ObjectDBEntry oSchemaElement)
            : base(oConfigData, oPreCompData)
        {
            ValueConfig = oConfigData.STFConfig.BinaryValueFuzzer;

            ConfigDefinedValues = null;

            bool UsingCustomFuzzer = false;
            if (null != ValueConfig)
            {
                // Check if the user has assigned custom fuzzers for this node
                if (ValueConfig.CustomFuzzer != null)
                    for (int i = 0; i < ValueConfig.CustomFuzzer.Length; i++)
                    {
                        if (ValueConfig.CustomFuzzer[i].NodeNamespace.Equals(oSchemaElement.Name.Namespace, StringComparison.CurrentCultureIgnoreCase) &&
                            ValueConfig.CustomFuzzer[i].NodeName.Equals(oSchemaElement.Name.Name, StringComparison.CurrentCultureIgnoreCase))
                        {
                            AssignValueFuzzers(ValueConfig.CustomFuzzer[i]);
                            UsingCustomFuzzer = true;
                            Log.Write(MethodBase.GetCurrentMethod(), "Custom BinaryValue fuzzer being used", Log.LogType.LogOnlyInfo);
                            break;
                        }
                    }
                // Assign the default fuzzers if there is no custom one
                if (!UsingCustomFuzzer && (ValueConfig.DefaultFuzzers != null))
                    AssignValueFuzzers(ValueConfig.DefaultFuzzers);

                // Find the length of the shortest value in FuzzingValues
                FuzzingValuesMinValueLength = Int32.MaxValue;
                if (null != FuzzingValues)
                {
                    for (int i = 0; i < FuzzingValues.Length; i++)
                    {
                        if (FuzzingValues[i].Length < FuzzingValuesMinValueLength)
                            FuzzingValuesMinValueLength = FuzzingValues[i].Length;
                    }
                }
            }
        }

        public override void Initialise()
        {
            base.Initialise();
            MaxFuzzIndex = CountOfCurrentNodes;
        }

        protected abstract void AssignValueFuzzers(ByteValueFuzzersType FuzzersType);

        protected byte[][] GetByteGroup(String ID)
        {
            for (int i = 0; i < ValueConfig.ByteGroup.Length; i++)
            {
                if (ID == ValueConfig.ByteGroup[i].ID)
                    return ValueConfig.ByteGroup[i].ByteValue;
            }
            Log.Write(MethodBase.GetCurrentMethod(), "Could not find a ByteGroup with ID='" + ID + "'.  The associated ByteValueFuzzer will be skipped.", Log.LogType.Warning);
            return null;
        }

        protected abstract void BinaryEditFn(int StartIndex, byte[] FuzzByteValues, ref byte[] OutputBytes);

        /// <summary>
        /// Changes the bytes of the target node at the specified positions
        /// </summary>
        /// <param name="FuzzIndex">The FuzzIndex</param>
        /// <param name="NodeIndex">The NodeIndex</param>
        /// <param name="ByteArrays">The array of bytes, one of which will be chosen by FuzzIndex to be the fuzzing value</param>
        /// <param name="ByteRange">Range specification</param>
        /// <returns>true to continue fuzzing, false to stop</returns>
        protected bool EditBytes(int FuzzIndex, int NodeIndex, byte[][] FuzzingValues, ValueRange ByteRange)
        {
            if (null == ValueConfig)
                return false;

            if (null == FuzzingValues)
                return false;
            if (0 == FuzzingValues.Length)
                return false;

            // Get the value that will contain the bytes we will replace
            if (NodeIndex >= 0)
            {
                // Get the encoded value
                String Value = oValuesEditor.GetValue(NodeIndex);

                byte[] TargetValue = new byte[0];

                // Make sure it is something
                if (!String.IsNullOrEmpty(Value))
                {
                    // Decode the value to binary
                    TargetValue = Coder.DecodeToBytes(Value);
                }

                // Since different nodes will be of different lengths, we need to continue fuzzing even if one node is very short
                if (MaxFuzzIndex < FuzzingValues.Length * TargetValue.Length)
                    MaxFuzzIndex = FuzzingValues.Length * TargetValue.Length;
                if (FuzzIndex >= MaxFuzzIndex)
                {
                    // Reset, for other fuzzers that will be used without Fuzzer.Initialise being called
                    MaxFuzzIndex = CountOfCurrentNodes;
                    return false;
                }

                // The order of fuzzing is to try each fuzzing value at each position, and when we run out of fuzzing values, we move
                // onto the next position.

                // Calculate the starting position
                int startpos = FuzzIndex / FuzzingValues.Length;

                // If we are using a ByteRange Length, then ensure that we are not in the situation where we would continually throw
                // SkipStateOutOfRangeException because the target node is a long byte array, but our ByteRange Length is short.
                // If our start poistion plus the shortest FuzzingValue would effect a byte outside of the ByteRange, then end
                // this fuzzer.  This is independant of the TargetValue length, since the ByteRange is absolute.
                if ((ByteRange.Length != 0) && (startpos + FuzzingValuesMinValueLength > ByteRange.StartIndex + ByteRange.Length))
                    return false;   // The start position is beyond the byte range specified, so finish fuzzing

                // Make sure we have got something to edit
                //if (FuzzIndex >= FuzzingValues.Length * TargetValue.Length)
                //    throw new SkipStateOutOfRangeException();
                if(startpos >= TargetValue.Length)
                    throw new SkipStateOutOfRangeException();

                // Choose a specific fuzzing value
                byte[] FuzzingValue = FuzzingValues[FuzzIndex % (FuzzingValues.Length)];

                // Check we are in the right range
                if (startpos < ByteRange.StartIndex)
                    throw new SkipStateOutOfRangeException();
                if ((ByteRange.Length != 0) && (startpos + FuzzingValue.Length > ByteRange.StartIndex + ByteRange.Length))
                    throw new SkipStateOutOfRangeException(); // Check if using the FuzzingValue would affect bytes outside our ByteRange
                if ((startpos - ByteRange.StartIndex) % ByteRange.StepSize != 0)
                    throw new SkipStateOutOfRangeException();

                if (startpos + FuzzingValue.Length <= TargetValue.Length)
                {
                    // Execute the binary edit function
                    BinaryEditFn(startpos, FuzzingValue, ref TargetValue);
                }
                else
                {
                    throw new SkipStateOutOfRangeException();
                }

                // Encode back to a string
                String NewValue = Coder.Encode(TargetValue);

                // Validate it
                if (Facets.Validate(NewValue))
                {
                    // Get the Editor to change the value
                    oValuesEditor.ChangeValue(NodeIndex, NewValue);
                }
                else
                    throw new SkipStateException();
            }
            else
                throw new SkipStateNoAllCaseException();
            // At this stage changing all the values at the same time seems like it would be fruitless

            return true;
        }
    }
}
