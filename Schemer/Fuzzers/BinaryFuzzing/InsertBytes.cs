using System;
using System.Collections.Generic;
using System.Text;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Schemer.AutoGenerated;

namespace Fuzzware.Schemer.Fuzzers.BinaryFuzzing
{
    class InsertBytes : BinaryFuzzerBase
    {
        public InsertBytes(ConfigData oConfigData, PreCompData oPreCompData, ObjectDBEntry oSchemaElement)
            : base(oConfigData, oPreCompData, oSchemaElement)
        {
        }

        protected override void AssignValueFuzzers(ByteValueFuzzersType FuzzersType)
        {
            if (null != FuzzersType.InsertBytes)
            {
                Add("InsertBytes", InsertBytesFn);
                FuzzingValues = GetByteGroup(FuzzersType.InsertBytes.ValueGroupRef);
                BytesVR = GetValueRange(FuzzersType.InsertBytes.ValueRangeRef, ValueConfig.ByteRange);
            }
        }

        protected override void BinaryEditFn(int StartIndex, byte[] FuzzByteValues, ref byte[] OutputBytes)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Inserts bytes into the current byte array value using the bytes specified in the user configured list.
        /// </summary>
        protected bool InsertBytesFn(int FuzzIndex, int NodeIndex)
        {
            if (null == ValueConfig)
                return false;

            if (null == FuzzingValues)
                return false;
            if (0 == FuzzingValues.Length)
                return false;

            // Get the value that will contain the bytes we will replace
            if (NodeIndex >= 0)
            {
                // Get the encoded value
                String Value = oValuesEditor.GetValue(NodeIndex);

                // Decode the value to binary
                byte[] TargetValue = Coder.DecodeToBytes(Value);

                // When inserting we can always insert, even if the byte array is empty
                if (MaxFuzzIndex < FuzzingValues.Length * (TargetValue.Length + 1))
                    MaxFuzzIndex = FuzzingValues.Length * (TargetValue.Length + 1);
                if (FuzzIndex >= MaxFuzzIndex)
                {
                    // Reset
                    MaxFuzzIndex = CountOfCurrentNodes;
                    return false;
                }

                // Calculate the start position
                int startpos = FuzzIndex / FuzzingValues.Length;

                //if (FuzzIndex >= FuzzingValues.Length * (TargetValue.Length + 1))
                //    throw new SkipStateOutOfRangeException();
                if (startpos >= (TargetValue.Length + 1))
                    throw new SkipStateOutOfRangeException();

                // Get the config insertion value
                byte[] FuzzBytes = FuzzingValues[FuzzIndex % (FuzzingValues.Length)];

                // Check we are in the right section
                if (startpos < BytesVR.StartIndex)
                    throw new SkipStateOutOfRangeException();
                // For insert, we ignore the length of the FuzzingValue, the ByteRange is treated as position from the StartIndex.
                // e.g. StartIndex = 5, Length = 3, we should insert at all FuzzingValues at array positions 5,6 and 7
                if ((BytesVR.Length != 0) && (startpos >= (BytesVR.StartIndex + BytesVR.Length)))
                    return false;   // Once our start position is beyond our range, we have finished this fuzzer.
                if ((startpos - BytesVR.StartIndex) % BytesVR.StepSize != 0)
                    throw new SkipStateOutOfRangeException();

                byte[] NewEditValues = new byte[TargetValue.Length + FuzzBytes.Length];
                // Make the insertion
                Array.Copy(TargetValue, 0, NewEditValues, 0, startpos);
                Array.Copy(FuzzBytes, 0, NewEditValues, startpos, FuzzBytes.Length);
                if (startpos < TargetValue.Length)
                    Array.Copy(TargetValue, startpos, NewEditValues, startpos + FuzzBytes.Length, TargetValue.Length - startpos);

                // Encode back to a string
                String NewValue = Coder.Encode(NewEditValues);

                // Validate it
                if (Facets.Validate(NewValue))
                {
                    // Get the Editor to change the value
                    oValuesEditor.ChangeValue(NodeIndex, NewValue);
                }
                else
                    throw new SkipStateException();
            }
            else
                throw new SkipStateNoAllCaseException();
            // At this stage changing all the values at the same time seems like it would be fruitless

            return true;
        }
    }
}
