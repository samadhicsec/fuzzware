using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Security.Cryptography;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Schemer.AutoGenerated;
using Fuzzware.Schemer.Editors;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Common.DataSchema.Restrictions;

namespace Fuzzware.Schemer.Fuzzers.RandomFuzzing
{
    /// <summary>
    /// The base class for random fuzzers, it should never be instantiated.
    /// </summary>
    class RandomFuzzerBase : FuzzerBase, ITypeFuzzer
    {
        protected SHA1 oHash;
        protected int HashByteLen;
        protected RNGCryptoServiceProvider oRNG;
        protected byte[] oRandomness;
        protected ObjectDBEntry oSchemaElement;
        protected uint MaxIterations;
        protected uint Iterations;

        protected String LastValue;
        protected int iLastFuzzIndex = Int32.MinValue;

        public RandomFuzzerBase(ConfigData oConfigData, PreCompData oPreCompData, ObjectDBEntry oSchemaElement)
            : base(oConfigData, oPreCompData)
        {
            this.oSchemaElement = oSchemaElement;
            ConfigDefinedValues = null;
        }

        public override void Initialise()
        {
            base.Initialise();

            oHash = SHA1CryptoServiceProvider.Create();
            HashByteLen = oHash.HashSize / 8;
            oRNG = new RNGCryptoServiceProvider();
            oRandomness = new byte[HashByteLen];
            oRNG.GetBytes(oRandomness);

            // Set the fuzz index to a random value
            byte[] FuzzIndexBytes = new byte[4];
            Array.Copy(oRandomness, FuzzIndexBytes, 4);
            iFuzzIndex = BitConverter.ToInt32(FuzzIndexBytes, 0);
            if (iFuzzIndex < 0)
                iFuzzIndex = iFuzzIndex * -1;
            Log.Write(MethodBase.GetCurrentMethod(), "Random fuzzer initialised with fuzz index " + iFuzzIndex, Log.LogType.LogOnlyInfo);

            Iterations = 0;
        }

        protected void AddFuzzer(String Name, RandomFuzzerType oRandomFuzzerType)
        {
            Add(Name, FuzzRandomValues);
            MaxIterations = oRandomFuzzerType.Iterations;
        }

        /// <summary>
        /// This is what allows us to do random fuzzing.  The next fuzz index should be set to be the hash
        /// of the previous state description string.
        /// </summary>
        public override void NextFuzzIndex()
        {
            // Hash the node name, node index and fuzz index
            oHash.Initialize();
            List<byte> hashInput = new List<byte>();
            hashInput.AddRange(Encoding.Unicode.GetBytes(oSchemaElement.Name.Namespace));
            hashInput.AddRange(Encoding.Unicode.GetBytes(oSchemaElement.Name.Name));
            hashInput.AddRange(BitConverter.GetBytes(iNodeIndex));
            hashInput.AddRange(BitConverter.GetBytes(iFuzzIndex));
            oRandomness = oHash.ComputeHash(hashInput.ToArray());

            // If there is only 1 node then fuzzing all and the just the 1 is the same, so just fuzz the one.
            if (1 == CountOfCurrentNodes)
                iNodeIndex = 0;
            else
                iNodeIndex = -1;

            // Set the fuzz index to a random value
            byte[] FuzzIndexBytes = new byte[4];
            Array.Copy(oRandomness, FuzzIndexBytes, 4);
            iFuzzIndex = BitConverter.ToInt32(FuzzIndexBytes, 0);
            if (iFuzzIndex < 0)
                iFuzzIndex = iFuzzIndex * -1;

            Iterations++;
        }

        /// <summary>
        /// Generate an UInt64 between 0 and MaxValue.  This will generate the random number uniformly.
        /// </summary>
        /// <param name="MaxValue">The max value, should be > 0</param>
        /// <returns></returns>
        protected UInt64 GenerateRandomValueInRange(UInt64 MaxValue)
        {
            if (0 == MaxValue)
                return 0;

            UInt64 Num = 0;
            byte[] baMaxValue = BitConverter.GetBytes(MaxValue);
            //int BitLength = (int)Math.Log((double)MaxValue, 2); 
            //int ByteLen = ((BitLength + 1) / 8);
            int ByteLen = baMaxValue.Length;
            byte[] RandomValueBytes = new byte[ByteLen];
            Array.Copy(oRandomness, 4, RandomValueBytes, 0, ByteLen);
            Num = BitConverter.ToUInt64(RandomValueBytes, 0);
            return Num % MaxValue;

            //if (ByteLen > 1)
            //{
            //    // Generate a base number that is uniformly selected from a multiply of 8 bits.
            //    byte[] RandomValueBytes = new byte[ByteLen - 1];
            //    Array.Copy(oRandomness, 4, RandomValueBytes, 0, ByteLen);
            //    Num = BitConverter.ToUInt64(RandomValueBytes, 0);
            //}
            //if (0 != BitLength % 8)
            //{
            //    oHash.Initialize();
            //    byte LastByte = baMaxVlaue[baMaxVlaue.Length - 1];
            //    byte[] MoreRandomness = oHash.ComputeHash(oRandomness, 12, 4);
            //    // Because we can only generate bytes of random data, we need to generate smaller random numbers and add them
            //    // so there sum is uniformly selected from the entire possible range
            //    for (int i = 0; i < BitLength - (8 * ByteLen); i++)
            //    {
            //        if ((LastByte & (1 << i)) > 0)
            //        {
            //            // Generate random number in this range
            //            Num += (Int64)(MoreRandomness[i] & (0xFF >> (8 - i)));
            //        }
            //    }
            //}
        }

        protected virtual bool CreateRandomValues(int FuzzIndex, int NodeIndex, out String Value)
        {
            Value = "";
            return false;
        }

        protected virtual bool FuzzRandomValues(int FuzzIndex, int NodeIndex)
        {
            if (Iterations >= MaxIterations)
                return false;

            // We use the same random value for each node, so re-use the value rather than re-calculating it.
            if (iLastFuzzIndex == FuzzIndex)
            {
                ChangeToValue(LastValue, NodeIndex);
                return true;
            }

            String Value;

            // Call the function from a derived class that actually generates the value
            if (!CreateRandomValues(FuzzIndex, NodeIndex, out Value))
                return false;

            // Assign the new value
            ChangeToValue(Value, iNodeIndex);

            // Remember the new value
            LastValue = Value;
            iLastFuzzIndex = iFuzzIndex;

            return true;
        }
    }
}
