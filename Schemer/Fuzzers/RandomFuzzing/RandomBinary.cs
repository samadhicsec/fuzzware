using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Security.Cryptography;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Schemer.AutoGenerated;
using Fuzzware.Schemer.Editors;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Common.DataSchema.Restrictions;

namespace Fuzzware.Schemer.Fuzzers.RandomFuzzing
{
    class RandomBinary : RandomFuzzerBase
    {
        protected BinaryValueFuzzer ValueConfig;
        
        public RandomBinary(ConfigData oConfigData, PreCompData oPreCompData, ObjectDBEntry oSchemaElement)
            : base(oConfigData, oPreCompData, oSchemaElement)
        {
            ValueConfig = oConfigData.STFConfig.BinaryValueFuzzer;
            
            bool UsingCustomFuzzer = false;
            // Check if the user has assigned custom fuzzers for this node
            if (null != ValueConfig)
            {
                if (ValueConfig.CustomFuzzer != null)
                    for (int i = 0; i < ValueConfig.CustomFuzzer.Length; i++)
                    {
                        if (ValueConfig.CustomFuzzer[i].NodeNamespace.Equals(oSchemaElement.Name.Namespace, StringComparison.CurrentCultureIgnoreCase) &&
                            ValueConfig.CustomFuzzer[i].NodeName.Equals(oSchemaElement.Name.Name, StringComparison.CurrentCultureIgnoreCase))
                        {
                            AssignValueFuzzers(ValueConfig.CustomFuzzer[i]);
                            UsingCustomFuzzer = true;
                            Log.Write(MethodBase.GetCurrentMethod(), "Custom IntegerValue fuzzer being used", Log.LogType.LogOnlyInfo);
                            break;
                        }
                    }
                // Assign the default fuzzers if there is no custom one
                if (!UsingCustomFuzzer && (ValueConfig.DefaultFuzzers != null))
                    AssignValueFuzzers(ValueConfig.DefaultFuzzers);
            }
        }

        private void AssignValueFuzzers(ByteValueFuzzersType FuzzersType)
        {
            if (FuzzersType.RandomBinary != null)
            {
                AddFuzzer("RandomBinary", FuzzersType.RandomBinary);
            }
        }

        protected override bool CreateRandomValues(int FuzzIndex, int NodeIndex, out String Value)
        {
            // Try to get the length range of the binary blob
            TypeRestrictor oRestrictions = (oSchemaElement as ElementDBEntry).FacetRestrictor;

            uint MaxLength = oRestrictions.GetMaxLength();
            uint MinLength = oRestrictions.GetMinLength();

            byte[] CurrentValue;
            if (-1 == iNodeIndex)
            {
                // Find the longest value, and use it, since it could be used for our max length
                string MaxLengthValue = "";
                string[] oValues = oValuesEditor.GetAllValues();
                for (int i = 0; i < oValues.Length; i++)
                    if (oValues[i].Length > MaxLengthValue.Length)
                        MaxLengthValue = oValues[i];
                CurrentValue = Coder.DecodeToBytes(MaxLengthValue);
            }
            else
                CurrentValue = Coder.DecodeToBytes(oValuesEditor.GetValue(NodeIndex));

            // If no max length has been specified then change the max length to be the current length
            if (MaxLength == UInt32.MaxValue)
            {
                // TODO what if the current length is 0?
                MaxLength = (uint)CurrentValue.Length;
            }
            
            // Choose a random length
            UInt64 Length = MaxLength;
            if (MaxLength != MinLength)
            {
                Length = GenerateRandomValueInRange(MaxLength - MinLength);
                Length = MinLength + Length;
            }

            byte[] ByteValue = new byte[Length];
            // Generate the random bytes
            UInt64 ByteCount = 0;
            oHash.Initialize();
            byte[] MoreRandomness = oHash.ComputeHash(oRandomness, 4, HashByteLen - 4);
            while (ByteCount < Length)
            {
                if ((int)(Length - ByteCount) < (HashByteLen - 1))
                {
                    Array.Copy(MoreRandomness, 0, ByteValue, (int)ByteCount, (int)(Length - ByteCount));
                    ByteCount += (Length - ByteCount);
                }
                else
                {
                    Array.Copy(MoreRandomness, 0, ByteValue, (int)ByteCount, (int)(HashByteLen - 1));
                    ByteCount += (UInt64)(HashByteLen - 1);
                }
                // Generate more randomness
                oHash.Initialize();
                MoreRandomness = oHash.ComputeHash(MoreRandomness, HashByteLen - 1, 1);
            }

            Value = Coder.Encode(ByteValue);
            
            return true;
        }
    }
}
