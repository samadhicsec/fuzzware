using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Security.Cryptography;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Schemer.AutoGenerated;
using Fuzzware.Schemer.Editors;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Common.DataSchema.Restrictions;

namespace Fuzzware.Schemer.Fuzzers.RandomFuzzing
{
    class RandomInteger : RandomFuzzerBase
    {
        protected IntegerValueFuzzer ValueConfig;

        public RandomInteger(ConfigData oConfigData, PreCompData oPreCompData, ObjectDBEntry oSchemaElement)
            : base(oConfigData, oPreCompData, oSchemaElement)
        {
            ValueConfig = oConfigData.STFConfig.IntegerValueFuzzer;
            
            bool UsingCustomFuzzer = false;
            // Check if the user has assigned custom fuzzers for this node
            if (null != ValueConfig)
            {
                if (ValueConfig.CustomFuzzer != null)
                    for (int i = 0; i < ValueConfig.CustomFuzzer.Length; i++)
                    {
                        if (ValueConfig.CustomFuzzer[i].NodeNamespace.Equals(oSchemaElement.Name.Namespace, StringComparison.CurrentCultureIgnoreCase) &&
                            ValueConfig.CustomFuzzer[i].NodeName.Equals(oSchemaElement.Name.Name, StringComparison.CurrentCultureIgnoreCase))
                        {
                            AssignValueFuzzers(ValueConfig.CustomFuzzer[i]);
                            UsingCustomFuzzer = true;
                            Log.Write(MethodBase.GetCurrentMethod(), "Custom IntegerValue fuzzer being used", Log.LogType.LogOnlyInfo);
                            break;
                        }
                    }
                // Assign the default fuzzers if there is no custom one
                if (!UsingCustomFuzzer && (ValueConfig.DefaultFuzzers != null))
                    AssignValueFuzzers(ValueConfig.DefaultFuzzers);
            }
        }

        private void AssignValueFuzzers(IntegerValueFuzzersType FuzzersType)
        {
            if (FuzzersType.RandomInteger != null)
            {
                AddFuzzer("RandomInteger", FuzzersType.RandomInteger);
            }
        }

        protected override bool CreateRandomValues(int FuzzIndex, int NodeIndex, out string StrValue)
        {
            StrValue = "";
            // Convert the randomness into an integer value
            
            // Get restrictions on output shorts, words etc
            TypeRestrictor oRestrictions = (oSchemaElement as ElementDBEntry).FacetRestrictor;
            
            if (oRestrictions is NumberTypeRestrictor<UInt64>)
            {
                UInt64 MinIncl;
                if(!(oRestrictions as NumberTypeRestrictor<UInt64>).GetMinInclusive(out MinIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<UInt64>).GetMinExclusive(out MinIncl);
                    MinIncl = MinIncl + 1;
                }
                UInt64 MaxIncl;
                if (!(oRestrictions as NumberTypeRestrictor<UInt64>).GetMaxInclusive(out MaxIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<UInt64>).GetMaxExclusive(out MaxIncl);
                    MaxIncl = MaxIncl - 1;
                }
                UInt64 Range = MaxIncl - MinIncl;
                if (0 == Range)     // min and max are the same
                    return false;
                if(Range < UInt64.MaxValue)
                    Range = Range + 1;  // we are using inclusive values
                UInt64 Value = MinIncl + GenerateRandomValueInRange(Range);
                //ChangeToValue(Value.ToString(), iNodeIndex);
                StrValue = Value.ToString();
            }
            else if (oRestrictions is NumberTypeRestrictor<UInt32>)
            {
                UInt32 MinIncl;
                if (!(oRestrictions as NumberTypeRestrictor<UInt32>).GetMinInclusive(out MinIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<UInt32>).GetMinExclusive(out MinIncl);
                    MinIncl = MinIncl + 1;
                }
                UInt32 MaxIncl;
                if (!(oRestrictions as NumberTypeRestrictor<UInt32>).GetMaxInclusive(out MaxIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<UInt32>).GetMaxExclusive(out MaxIncl);
                    MaxIncl = MaxIncl - 1;
                }
                UInt64 Range = (UInt64)MaxIncl - (UInt64)MinIncl;
                if (0 == Range)     // min and max are the same
                    return false;
                Range = Range + 1;  // we are using inclusive values
                UInt32 Value = MinIncl + (UInt32)GenerateRandomValueInRange(Range);
                //ChangeToValue(Value.ToString(), iNodeIndex);
                StrValue = Value.ToString();
            }
            else if (oRestrictions is NumberTypeRestrictor<UInt16>)
            {
                UInt16 MinIncl;
                if (!(oRestrictions as NumberTypeRestrictor<UInt16>).GetMinInclusive(out MinIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<UInt16>).GetMinExclusive(out MinIncl);
                    MinIncl = (UInt16)(MinIncl + 1);
                }
                UInt16 MaxIncl;
                if (!(oRestrictions as NumberTypeRestrictor<UInt16>).GetMaxInclusive(out MaxIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<UInt16>).GetMaxExclusive(out MaxIncl);
                    MaxIncl = (UInt16)(MaxIncl - 1);
                }
                UInt64 Range = (UInt64)MaxIncl - (UInt64)MinIncl;
                if (0 == Range)     // min and max are the same
                    return false;
                Range = Range + 1;  // we are using inclusive values
                UInt16 Value = (UInt16)(MinIncl + (UInt16)GenerateRandomValueInRange(Range));
                //ChangeToValue(Value.ToString(), iNodeIndex);
                StrValue = Value.ToString();
            }
            else if (oRestrictions is NumberTypeRestrictor<Byte>)
            {
                Byte MinIncl;
                if (!(oRestrictions as NumberTypeRestrictor<Byte>).GetMinInclusive(out MinIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<Byte>).GetMinExclusive(out MinIncl);
                    MinIncl = (Byte)(MinIncl + 1);
                }
                Byte MaxIncl;
                if (!(oRestrictions as NumberTypeRestrictor<Byte>).GetMaxInclusive(out MaxIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<Byte>).GetMaxExclusive(out MaxIncl);
                    MaxIncl = (Byte)(MaxIncl - 1);
                }
                UInt64 Range = (UInt64)MaxIncl - (UInt64)MinIncl;
                if (0 == Range)     // min and max are the same
                    return false;
                Range = Range + 1;  // we are using inclusive values
                Byte Value = (Byte)(MinIncl + (Byte)GenerateRandomValueInRange(Range));
                //ChangeToValue(Value.ToString(), iNodeIndex);
                StrValue = Value.ToString();
            }
            else if (oRestrictions is NumberTypeRestrictor<Int64>)
            {
                Int64 MinIncl;
                if (!(oRestrictions as NumberTypeRestrictor<Int64>).GetMinInclusive(out MinIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<Int64>).GetMinExclusive(out MinIncl);
                    MinIncl = MinIncl + 1;
                }
                Int64 MaxIncl;
                if (!(oRestrictions as NumberTypeRestrictor<Int64>).GetMaxInclusive(out MaxIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<Int64>).GetMaxExclusive(out MaxIncl);
                    MaxIncl = MaxIncl - 1;
                }
                UInt64 Range = (UInt64)MaxIncl - (UInt64)MinIncl;
                if (0 == Range)     // min and max are the same
                    return false;
                Range = Range + 1;  // we are using inclusive values
                Int64 Value = 0;
                if(MinIncl < 0)
                    Value = (Int64)(GenerateRandomValueInRange(Range) - (UInt64)(-1*MinIncl));
                else
                    Value = (Int64)((UInt64)MinIncl + GenerateRandomValueInRange(Range));
                //ChangeToValue(Value.ToString(), iNodeIndex);
                StrValue = Value.ToString();
            }
            else if (oRestrictions is NumberTypeRestrictor<Int32>)
            {
                Int32 MinIncl;
                if (!(oRestrictions as NumberTypeRestrictor<Int32>).GetMinInclusive(out MinIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<Int32>).GetMinExclusive(out MinIncl);
                    MinIncl = MinIncl + 1;
                }
                Int32 MaxIncl;
                if (!(oRestrictions as NumberTypeRestrictor<Int32>).GetMaxInclusive(out MaxIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<Int32>).GetMaxExclusive(out MaxIncl);
                    MaxIncl = MaxIncl - 1;
                }
                UInt64 Range = (UInt64)MaxIncl - (UInt64)MinIncl;
                if (0 == Range)     // min and max are the same
                    return false;
                Range = Range + 1;  // we are using inclusive values
                Int32 Value = (Int32)(MinIncl + (Int64)GenerateRandomValueInRange(Range));
                //ChangeToValue(Value.ToString(), iNodeIndex);
                StrValue = Value.ToString();
            }
            else if (oRestrictions is NumberTypeRestrictor<Int16>)
            {
                Int16 MinIncl;
                if (!(oRestrictions as NumberTypeRestrictor<Int16>).GetMinInclusive(out MinIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<Int16>).GetMinExclusive(out MinIncl);
                    MinIncl = (Int16)(MinIncl + 1);
                }
                Int16 MaxIncl;
                if (!(oRestrictions as NumberTypeRestrictor<Int16>).GetMaxInclusive(out MaxIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<Int16>).GetMaxExclusive(out MaxIncl);
                    MaxIncl = (Int16)(MaxIncl - 1);
                }
                UInt64 Range = (UInt64)MaxIncl - (UInt64)MinIncl;
                if (0 == Range)     // min and max are the same
                    return false;
                Range = Range + 1;  // we are using inclusive values
                Int16 Value = (Int16)(MinIncl + (Int32)GenerateRandomValueInRange(Range));
                //ChangeToValue(Value.ToString(), iNodeIndex);
                StrValue = Value.ToString();
            }
            else if (oRestrictions is NumberTypeRestrictor<SByte>)
            {
                SByte MinIncl;
                if (!(oRestrictions as NumberTypeRestrictor<SByte>).GetMinInclusive(out MinIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<SByte>).GetMinExclusive(out MinIncl);
                    MinIncl = (SByte)(MinIncl + 1);
                }
                SByte MaxIncl;
                if (!(oRestrictions as NumberTypeRestrictor<SByte>).GetMaxInclusive(out MaxIncl))
                {
                    (oRestrictions as NumberTypeRestrictor<SByte>).GetMaxExclusive(out MaxIncl);
                    MaxIncl = (SByte)(MaxIncl - 1);
                }
                UInt64 Range = (UInt64)MaxIncl - (UInt64)MinIncl;
                if (0 == Range)     // min and max are the same
                    return false;
                Range = Range + 1;  // we are using inclusive values
                SByte Value = (SByte)(MinIncl + (Int16)GenerateRandomValueInRange(Range));
                //ChangeToValue(Value.ToString(), iNodeIndex);
                StrValue = Value.ToString();
            }

            return true;
        }
    }
}
