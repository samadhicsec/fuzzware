using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Security.Cryptography;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Schemer.AutoGenerated;
using Fuzzware.Schemer.Editors;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Common.DataSchema.Restrictions;

namespace Fuzzware.Schemer.Fuzzers.RandomFuzzing
{
    class RandomBitFlip : RandomFuzzerBase
    {
        protected BinaryValueFuzzer ValueConfig;
        UInt64 RandomBitOffset;
        UInt64 lcm;

        public RandomBitFlip(ConfigData oConfigData, PreCompData oPreCompData, ObjectDBEntry oSchemaElement)
            : base(oConfigData, oPreCompData, oSchemaElement)
        {
            ValueConfig = oConfigData.STFConfig.BinaryValueFuzzer;
            
            bool UsingCustomFuzzer = false;
            // Check if the user has assigned custom fuzzers for this node
            if (null != ValueConfig)
            {
                if (ValueConfig.CustomFuzzer != null)
                    for (int i = 0; i < ValueConfig.CustomFuzzer.Length; i++)
                    {
                        if (ValueConfig.CustomFuzzer[i].NodeNamespace.Equals(oSchemaElement.Name.Namespace, StringComparison.CurrentCultureIgnoreCase) &&
                            ValueConfig.CustomFuzzer[i].NodeName.Equals(oSchemaElement.Name.Name, StringComparison.CurrentCultureIgnoreCase))
                        {
                            AssignValueFuzzers(ValueConfig.CustomFuzzer[i]);
                            UsingCustomFuzzer = true;
                            Log.Write(MethodBase.GetCurrentMethod(), "Custom IntegerValue fuzzer being used", Log.LogType.LogOnlyInfo);
                            break;
                        }
                    }
                // Assign the default fuzzers if there is no custom one
                if (!UsingCustomFuzzer && (ValueConfig.DefaultFuzzers != null))
                    AssignValueFuzzers(ValueConfig.DefaultFuzzers);
            }
        }

        private void AssignValueFuzzers(ByteValueFuzzersType FuzzersType)
        {
            if (FuzzersType.RandomBitFlip != null)
            {
                AddFuzzer("RandomBitFlip", FuzzersType.RandomBitFlip);
            }
        }

        public override void Initialise()
        {
            base.Initialise();

            List<int> NodeLengths = new List<int>();
            
            // Create a list of all the lengths
            string[] oValues = oValuesEditor.GetAllValues();
            for (int i = 0; i < oValues.Length; i++)
            {
                byte[] Node = Coder.DecodeToBytes(oValues[i]);
                if ((0 != Node.Length) && (!NodeLengths.Contains(Node.Length)))
                    NodeLengths.Add(Node.Length);
            }
            // Find the least common multiple of the bit length
            if (0 == NodeLengths.Count)
                lcm = 0;
            else
                lcm = 1;
            for (int i = 0; i < NodeLengths.Count; i++)
                lcm = lcm * (ulong)(NodeLengths[i] * 8);
        }

        protected override bool CreateRandomValues(int FuzzIndex, int NodeIndex, out String Value)
        {
            byte[] CurrentValue = Coder.DecodeToBytes(oValuesEditor.GetValue(NodeIndex));

            if (0 == CurrentValue.Length)
                throw new SkipStateOutOfRangeException();

            // Change the bit at the offset (since RandomBitOffset was chosen from the lcm of all the node bit lengths,
            // using RandomBitOffset modulo the current node bit length is equivalent to uniformly selecting it from
            // the current node bit length range)
            UInt64 ModRandomBitOffset = RandomBitOffset % (ulong)(CurrentValue.Length * 8);
            UInt64 ByteOffset = ModRandomBitOffset / 8;
            byte BitOffset = (byte)(ModRandomBitOffset % 8);

            CurrentValue[ByteOffset] = (byte)(CurrentValue[ByteOffset] ^ ((byte)1 << BitOffset));

            // Set the return value
            Value = Coder.Encode(CurrentValue);
            
            return true;
        }

        protected override bool FuzzRandomValues(int FuzzIndex, int NodeIndex)
        {
            if (Iterations >= MaxIterations)
                return false;

            if(NodeIndex < 0)
                throw new SkipStateNoAllCaseException();

            if (0 == lcm)
                throw new SkipStateException();

            if (iLastFuzzIndex != FuzzIndex)
            {
                // Select a random value in this range
                RandomBitOffset = GenerateRandomValueInRange(lcm);
            }
            
            String Value;
            // Call the function from a derived class that actually generates the value
            if (!CreateRandomValues(FuzzIndex, NodeIndex, out Value))
                return false;

            // Assign the new value
            ChangeToValue(Value, iNodeIndex);

            // Remember this FuzzIndex
            iLastFuzzIndex = FuzzIndex;

            return true;
        }
    }
}
