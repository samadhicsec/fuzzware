using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Security.Cryptography;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Schemer.AutoGenerated;
using Fuzzware.Schemer.Editors;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Common.DataSchema.Restrictions;

namespace Fuzzware.Schemer.Fuzzers.RandomFuzzing
{
    class RandomDecimal : RandomFuzzerBase
    {
        protected DecimalValueFuzzer ValueConfig;
        protected byte[] oMoreRandomness;

        public RandomDecimal(ConfigData oConfigData, PreCompData oPreCompData, ObjectDBEntry oSchemaElement)
            : base(oConfigData, oPreCompData, oSchemaElement)
        {
            ValueConfig = oConfigData.STFConfig.DecimalValueFuzzer;
            
            bool UsingCustomFuzzer = false;
            // Check if the user has assigned custom fuzzers for this node
            if (null != ValueConfig)
            {
                if (ValueConfig.CustomFuzzer != null)
                    for (int i = 0; i < ValueConfig.CustomFuzzer.Length; i++)
                    {
                        if (ValueConfig.CustomFuzzer[i].NodeNamespace.Equals(oSchemaElement.Name.Namespace, StringComparison.CurrentCultureIgnoreCase) &&
                            ValueConfig.CustomFuzzer[i].NodeName.Equals(oSchemaElement.Name.Name, StringComparison.CurrentCultureIgnoreCase))
                        {
                            AssignValueFuzzers(ValueConfig.CustomFuzzer[i]);
                            UsingCustomFuzzer = true;
                            Log.Write(MethodBase.GetCurrentMethod(), "Custom IntegerValue fuzzer being used", Log.LogType.LogOnlyInfo);
                            break;
                        }
                    }
                // Assign the default fuzzers if there is no custom one
                if (!UsingCustomFuzzer && (ValueConfig.DefaultFuzzers != null))
                    AssignValueFuzzers(ValueConfig.DefaultFuzzers);
            }
        }

        private void AssignValueFuzzers(DecimalValueFuzzersType FuzzersType)
        {
            if (FuzzersType.RandomDecimal != null)
            {
                AddFuzzer("RandomDecimal", FuzzersType.RandomDecimal);
            }
        }

        protected Double GenerateRandomDoubleInRange(Double MaxValue, bool IsExclusive)
        {
            // TODO: Find a better way to generate random doubles.  Currently we tend to generate either
            // very small of very large values, which since we add to the min value, we tend to get
            // numbers very close to the min value or very big
            if (0 == MaxValue)
                return 0;

            Double Num = 0;
            byte[] baMaxValue = BitConverter.GetBytes(MaxValue);
            int ByteLen = baMaxValue.Length;
            byte[] RandomValueBytes = new byte[ByteLen];
            Array.Copy(oMoreRandomness, 4, RandomValueBytes, 0, ByteLen);
            Num = BitConverter.ToDouble(RandomValueBytes, 0);
            // We need to create a random positive number
            if (Num < 0.0)
                Num = -1.0 * Num;
            return Num % MaxValue;
        }

        protected override bool CreateRandomValues(int FuzzIndex, int NodeIndex, out string StrValue)
        {
            StrValue = "";
            // Convert the randomness into an integer value
            
            // Get restrictions on output shorts, words etc
            TypeRestrictor oRestrictions = (oSchemaElement as ElementDBEntry).FacetRestrictor;

            if (oRestrictions is DoubleTypeRestrictor)
            {
                bool MinValueIsExclusive = false;
                Double MinValue;
                if (!(oRestrictions as DoubleTypeRestrictor).GetMinInclusive(out MinValue))
                {
                    (oRestrictions as DoubleTypeRestrictor).GetMinExclusive(out MinValue);
                    MinValueIsExclusive = true;
                }
                bool MaxValueIsExclusive = false;
                Double MaxValue;
                if (!(oRestrictions as DoubleTypeRestrictor).GetMaxInclusive(out MaxValue))
                {
                    (oRestrictions as DoubleTypeRestrictor).GetMaxExclusive(out MaxValue);
                    MaxValueIsExclusive = true;
                }
                Double Range = MaxValue - MinValue;
                if (0 == Range)     // min and max are the same
                    return false;
                if (Double.IsInfinity(Range))
                    Range = Double.MaxValue;
                if (Range < 0.0)
                    Range = -1.0 * Range;

                oMoreRandomness = new byte[oRandomness.Length];
                Array.Copy(oRandomness, oMoreRandomness, oRandomness.Length);
                Double RandomValue = GenerateRandomDoubleInRange(Range, MaxValueIsExclusive);

                // If the min value was exclusive then the random value cannot be 0. (as we add RandomValue to the min value,
                // so if it was 0 we would get the min value)
                // Or, if RandomValue is so small that adding it to MinValue has no effect (which is quite often) 
                // then Value = MinValue a lot which isn't very random
                int count = 0;
                if ((MinValueIsExclusive) || ((MinValue + RandomValue) == MinValue))
                    while (((RandomValue == 0.0) || ((MinValue + RandomValue) == MinValue)) && (count < 100))
                    {
                        oHash.Initialize();
                        oMoreRandomness = oHash.ComputeHash(oMoreRandomness, 0, 4);
                        RandomValue = GenerateRandomDoubleInRange(Range, MaxValueIsExclusive);
                    }
                if (count >= 100)
                    throw new SkipStateException();

                Double Value = MinValue + RandomValue;
                StrValue = Value.ToString();
            }
            else if (oRestrictions is SingleTypeRestrictor)
            {
                bool MinValueIsExclusive = false;
                Single MinValue;
                if (!(oRestrictions as SingleTypeRestrictor).GetMinInclusive(out MinValue))
                {
                    (oRestrictions as SingleTypeRestrictor).GetMinExclusive(out MinValue);
                    MinValueIsExclusive = true;
                }
                bool MaxValueIsExclusive = false;
                Single MaxValue;
                if (!(oRestrictions as SingleTypeRestrictor).GetMaxInclusive(out MaxValue))
                {
                    (oRestrictions as SingleTypeRestrictor).GetMaxExclusive(out MaxValue);
                    MaxValueIsExclusive = true;
                }
                Double Range = (Double)MaxValue - (Double)MinValue;
                if (0 == Range)     // min and max are the same
                    return false;

                oMoreRandomness = new byte[oRandomness.Length];
                Array.Copy(oRandomness, oMoreRandomness, oRandomness.Length);
                Double RandomValue = GenerateRandomDoubleInRange(Range, MaxValueIsExclusive);

                // If the min value was exclusive then the random value cannot be 0 (as we add RandomValue to the min value,
                // so if it was 0 we would get the min value)
                // Or, if RandomValue is so small adding it to MinValue has no effect (which is quite often) 
                // then Value = MinValue a lot which isn't very random
                int count = 0;
                if ((MinValueIsExclusive) || ((Single)(MinValue + RandomValue) == MinValue))
                    while ((((Single)RandomValue == 0.0) || ((Single)(MinValue + RandomValue) == MinValue)) && (count < 100))
                    {
                        oHash.Initialize();
                        oMoreRandomness = oHash.ComputeHash(oMoreRandomness, 0, 4);
                        RandomValue = GenerateRandomDoubleInRange(Range, MaxValueIsExclusive);
                    }
                if (count >= 100)
                    throw new SkipStateException();

                Single Value = (Single)(MinValue + RandomValue);
                StrValue = Value.ToString();
            }
            else
            {
                // Reasons :
                // - XML Schema decimals are different to CLR decimals
                // - Have coded for XSD decimals (as a high level base class), so restrictions are hard to enforce
                // - Cannot directly create random decimals as BitConverter has no ToDecimal method
                // - Casting or coverting between Doubles and Decimals either causes compiler issues or throws exceptions
                Log.Write(MethodBase.GetCurrentMethod(), "Cannot create random decimals, only doubles and singles.", Log.LogType.Warning);
                return false;
            }
            

            return true;
        }
    }
}
