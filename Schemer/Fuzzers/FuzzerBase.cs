using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using Fuzzware.Schemer.Editors;
using Fuzzware.Common.DataSchema.Restrictions;
using Fuzzware.Common;
using Fuzzware.Common.Encoding;
using Fuzzware.Schemer.AutoGenerated;

namespace Fuzzware.Schemer.Fuzzers
{
    public class FuzzerBase
    {
        /// <summary>
        /// When implementing a FuzzerFunction delegate, the return value should only be false when the Index passed in is greater than
        /// the maximum Index the function supports.
        /// </summary>
        /// <returns>true to continue using this function, false to stop.</returns>
        public delegate bool FuzzerFunction(int FuzzIndex, int NodeIndex);

        protected ConfigData oConfigData;
        protected PreCompData oPreCompData;
        protected List<String> Categories;
        protected List<FuzzerFunction> Delegates;
        protected int CurrentCategory;
        protected TypeRestrictor Facets;
        protected IValuesEditor oValuesEditor;
        protected String[] ConfigDefinedValues;
        protected Coder Coder;

        // State information
        protected int iFuzzIndex;
        protected int iNodeIndex;
        protected bool bFinished;
        protected bool bFinishOnNext;

        // End state info
        protected bool bEndStateSpecified;
        protected int EndCategoryIndex;
        protected int iEndFuzzIndex;
        protected int iEndNodeIndex;
        
        public FuzzerBase(ConfigData oConfigData, PreCompData oPreCompData)
        {
            this.oConfigData = oConfigData;
            this.oPreCompData = oPreCompData;
            Categories = new List<string>();
            Delegates = new List<FuzzerFunction>();
            Categories.Add("Finished");
            Delegates.Add(Finished);

            CurrentCategory = 0;

            Coder = new Coder();
        }

        public IFacetRestrictions FacetRestrictions
        {
            get
            {
                return Facets;
            }
            set
            {
                Facets = value as TypeRestrictor;
            }
        }

        protected virtual int CountOfCurrentNodes
        {
            get
            {
                if (null != oValuesEditor)
                {
                    return oValuesEditor.NodeCount();
                }
                Log.Write(MethodBase.GetCurrentMethod(), "Unable to return CountOfCurrentNodes, oValuesEditor was null", Log.LogType.Error);
                return 0;
            }
        }

        #region ITypeFuzzer Members
        
        public virtual String[] Methods()
        {
            String[] ret = Categories.ToArray();
            // Remove the 'Finished' method
            Array.Resize<String>(ref ret, ret.Length - 1);
            return ret;
        }

        public virtual void Initialise()
        {
            // Initialise the Values Editor
            if (null != oValuesEditor)
            {
                oValuesEditor.Initialise();
            }

            // Set to first Category
            CurrentCategory = 0;
            iFuzzIndex = 0;
            iNodeIndex = (1 == CountOfCurrentNodes) ? 0 : -1;
            bFinishOnNext = false;

            // Log the fuzzing that will occur
            //Log.Write(MethodBase.GetCurrentMethod(), "
        }

        public virtual IValuesEditor ValuesEditor
        {
            set
            {
                oValuesEditor = value;
            }
        }

        public Coder FuzzCoder
        {
            set
            {
                Coder = value;
            }
        }

        public virtual void Restore()
        {
            if (null != oValuesEditor)
                oValuesEditor.RestoreValue(iNodeIndex);
        }

        public virtual void End()
        {
            
        }
        #endregion

        public void Fuzz()
        {
            // Relies on the final category delegate being Finished
            while (!Delegates[CurrentCategory](iFuzzIndex, iNodeIndex))
            {
                // Increment the category/fuzzer
                CurrentCategory++;
                
                // Reset the fuzz index to zero and the node index to -1 or 0 depending if there is more than 1 node
                iFuzzIndex = 0;
                iNodeIndex = (1 == CountOfCurrentNodes) ? 0 : -1;
            }

            // Check for the end state.  
            //if (bEndStateSpecified && (CurrentCategory == EndCategoryIndex))
            //{
            //    // If this is the final state, set the fuzzer to finished next time we move state
            //    if ((iFuzzIndex == iEndFuzzIndex) && (iNodeIndex == iEndNodeIndex))
            //    {
            //        bFinishOnNext = true;
            //    }
            //}
        }

        private bool Finished(int FuzzIndex, int NodeIndex)
        {
            bFinished = true;
            iFuzzIndex = 0;
            iNodeIndex = 0;
            return true;
        }

        public void Add(String CategoryName, FuzzerFunction Function)
        {
            Categories.Insert(Categories.Count - 1, CategoryName);
            Delegates.Insert(Delegates.Count - 1, Function);
        }

        protected void ChangeToValue(String Value, int NodeIndex)
        {
            // Validate the fuzzed value against the possible restrictions for registered type
            // Facet restrictions should be applied to the value that appears in the XML, 
            //  - if encoded, facet restrictions should apply to the encoded value, as no facet resetrictions could have
            //    been specified for the value inside the encoding
            //  - if it to be encoded on output (outputAs), then we assume it is presented unencoded so facet restrictions
            //    could be applied to it
            //  - if unencoded, this is the usual case
            // Note: Value should always be the value in the form it appears in the input XML, even if we are treating it as an
            // encoded value, and fuzzing accordingly (e.g if input is Base64, and we are binary fuzzing the contents of the
            // Base64, Value will be in Base64)
            if (Facets.Validate(Value))
            {
                oValuesEditor.ChangeValue(NodeIndex, Value);
            }
            else
            {
                throw new SkipStateException();
            }
        }

        /// <summary>
        /// A generic FuzzerFunction used to replace values with values from a config file.  Requires a child
        /// class to set ConfigDefinedValues and add this function as a fuzzer function (using Add)
        /// </summary>
        /// <param name="FuzzIndex"></param>
        /// <param name="NodeIndex"></param>
        /// <returns></returns>
        public bool FuzzConfigDefinedValues(int FuzzIndex, int NodeIndex)
        {
            if (null == ConfigDefinedValues)
                return false;
            if (FuzzIndex >= ConfigDefinedValues.Length)
                return false;

            ChangeToValue(ConfigDefinedValues[FuzzIndex], NodeIndex);
            return true;
        }

        protected ValueRange GetValueRange(String ID, ValueRange[] Ranges)
        {
            if (String.IsNullOrEmpty(ID))
                return new ValueRange();
            for (int i = 0; i < Ranges.Length; i++)
            {
                if (ID == Ranges[i].ID)
                    return Ranges[i];
            }
            Log.Write(MethodBase.GetCurrentMethod(), "A ValueRange ID was specified, but was not found, using default ValueRange", Log.LogType.Warning);
            return new ValueRange();
        }

        #region IFuzzState Members

        public virtual void Next()
        {
            // Check if we want to finish now.  We check here because Next is called after we have eval'ed the end state, otherwise
            // the fuzzer might think it has finished before it has eval'ed the end state.  Having the check here also catches the
            // skipped state case.
            if (bEndStateSpecified && (CurrentCategory == EndCategoryIndex))
            {
                // If this is the final state, set the fuzzer to finished next time we move state
                if ((iFuzzIndex == iEndFuzzIndex) && (iNodeIndex == iEndNodeIndex))
                {
                    bFinished = true;
                }
            }

            // Check if there are any more nodes of this type
            if (NextNodeIndex())
                return;

            // There aren't so reset the current node to be the first,  which depends ...
            NextFuzzIndex();
        }

        public virtual void NextFuzzIndex()
        {
            // If there is only 1 node then fuzzing all and the just the 1 is the same, so just fuzz the one.
            if (1 == CountOfCurrentNodes)
                iNodeIndex = 0;
            else
                iNodeIndex = -1;

            // Increment to the next fuzz test case
            iFuzzIndex++;
        }

        public virtual bool NextNodeIndex()
        {
            if (iNodeIndex < CountOfCurrentNodes - 1)
            {
                iNodeIndex++;
                return true;
            }
            return false;
        }

        public virtual bool NextFuzzType()
        {
            if (CurrentCategory < Categories.Count - 1)
            {
                CurrentCategory++;
                return true;
            }
            bFinished = true;
            return false;
        }

        public virtual void SetState(string NodeIndexStr, string TypeStr, uint FuzzIndex)
        {
            // Set the NodeIndex
            if (NodeIndexStr.Equals("All"))
                iNodeIndex = -1;
            else
            {
                int tempNodeIndex = -1;
                if (Int32.TryParse(NodeIndexStr, out tempNodeIndex))
                {
                    NodeIndex = tempNodeIndex;
                }
                else
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Could not convert '" + NodeIndexStr + "' to an Int32, defaulting to All case", Log.LogType.Warning);
                    NodeIndex = -1;
                }
            }
            // Set the fuzzer type
            this.Type = TypeStr;
            
            // Set the fuzz index
            this.FuzzIndex = (int)FuzzIndex;
        }

        public virtual void SetEndState(string NodeIndexStr, string TypeStr, uint FuzzIndex)
        {
            // Set the NodeIndex
            if (NodeIndexStr.Equals("All"))
                iEndNodeIndex = -1;
            else
            {
                int tempNodeIndex = -1;
                if (Int32.TryParse(NodeIndexStr, out tempNodeIndex))
                {
                    iEndNodeIndex = tempNodeIndex;
                }
                else
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Could not convert '" + NodeIndexStr + "' to an Int32, ignoring end state", Log.LogType.Warning);
                    return;
                }
            }
            // Set the fuzzer type
            EndCategoryIndex = -1;
            for (int i = 0; i < Categories.Count; i++)
            {
                if (Categories[i].Equals(TypeStr, StringComparison.CurrentCultureIgnoreCase))
                {
                    EndCategoryIndex = i;
                    break;
                }
            }
            if (-1 == EndCategoryIndex)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Could not set end fuzzer category to '" + TypeStr + "', ignoring end state", Log.LogType.Warning);
                return;
            }

            // Set the fuzz index
            iEndFuzzIndex = (int)FuzzIndex;

            bEndStateSpecified = true;
        }

        public virtual bool IsFinished
        {
            get { return bFinished; }
        }

        public virtual int FuzzIndex
        {
            get
            {
                return iFuzzIndex;
            }
            set
            {
                iFuzzIndex = value;
                if (iFuzzIndex < 0)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Cannot set fuzz index < 0, defaulting to 0", Log.LogType.Warning);
                    iFuzzIndex = 0;
                }
            }
        }

        public virtual int NodeIndex
        {
            get
            {
                return iNodeIndex;
            }
            set
            {
                iNodeIndex = value;
                if (iNodeIndex < -1)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Cannot set node index < -1, defaulting to -1", Log.LogType.Warning);
                    iNodeIndex = -1;
                }
                if (value >= CountOfCurrentNodes)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Cannot set node index to be greater than or equal to the count of the current node, defaulting to -1", Log.LogType.Warning);
                    iNodeIndex = -1;
                }
            }
        }

        public virtual string Type
        {
            get
            {
                return Categories[CurrentCategory];
            }
            set
            {
                CurrentCategory = -1;
                for(int i = 0; i < Categories.Count; i++)
                    if (Categories[i].Equals(value, StringComparison.CurrentCultureIgnoreCase))
                    {
                        CurrentCategory = i;
                        break;
                    }
                if (-1 == CurrentCategory)
                {
                    CurrentCategory = 0;
                    Log.Write(MethodBase.GetCurrentMethod(), "Could not set type to '" + value + "', defaulting to '" + Categories[CurrentCategory] + "'", Log.LogType.Warning);
                }
            }
        }

        #endregion
    }
}
