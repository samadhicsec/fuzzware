using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using Fuzzware.Schemer.AutoGenerated;
using Fuzzware.Common;
using Fuzzware.Common.DataSchema;
using Fuzzware.Common.XML;

namespace Fuzzware.Schemer.Fuzzers.NumberFuzzing
{
    abstract class AdjustIntegerBase : IntegerFuzzerBase
    {
        bool bIsSigned;

        public AdjustIntegerBase(ConfigData oConfigData, PreCompData oPreCompData, ObjectDBEntry oSchemaElement)
            : base(oConfigData, oPreCompData, oSchemaElement)
        {
            bIsSigned = IsSigned();
        }

        private bool IsSigned()
        {
            switch (oSchemaElement.DataSchemaType)
            {
                case DataSchemaTypeCode.PositiveInteger:
                case DataSchemaTypeCode.NonNegativeInteger:
                case DataSchemaTypeCode.UnsignedByte:
                case DataSchemaTypeCode.UnsignedShort:
                case DataSchemaTypeCode.UnsignedInt:
                case DataSchemaTypeCode.UnsignedLong:
                    return false;
                case DataSchemaTypeCode.Integer:
                case DataSchemaTypeCode.NegativeInteger:
                case DataSchemaTypeCode.NonPositiveInteger:
                case DataSchemaTypeCode.Byte:
                case DataSchemaTypeCode.Short:
                case DataSchemaTypeCode.Int:
                case DataSchemaTypeCode.Long:
                    return true;
                default:
                    Log.Write(MethodBase.GetCurrentMethod(), "'" + oSchemaElement.Name + "' is being fuzzed as an integer but has type '" +
                        oSchemaElement.DataSchemaType.ToString() + "'.  Ignoring", Log.LogType.Warning);
                    throw new SkipStateException();
            }

        }

        protected abstract Int64 OperateOn(int FuzzIndex, Int64 Value);
        protected abstract UInt64 OperateOn(int FuzzIndex, UInt64 Value);

        public bool AdjustInteger(int FuzzIndex, int NodeIndex)
        {
            if (null == ConfigDefinedValues)
                return false;
            if (FuzzIndex >= ConfigDefinedValues.Length)
                return false;

            int iNodeStartIndex = NodeIndex;
            int iNodeEndIndex = NodeIndex;
            if (-1 == NodeIndex)
            {
                // Change all the nodes simultaneously
                iNodeStartIndex = 0;
                iNodeEndIndex = CountOfCurrentNodes - 1;
            }

            for (int i = iNodeStartIndex; i <= iNodeEndIndex; i++)
            {
                // Get the current value of the node as an Int64
                String sNodeValue = oValuesEditor.GetValue(NodeIndex);

                if (bIsSigned)
                {
                    // Try to convert to signed Int64
                    Int64 iValue = 0;
                    if (!Int64.TryParse(sNodeValue, out iValue))
                    {
                        throw new SkipStateException();
                    }

                    oValuesEditor.ChangeValue(NodeIndex, OperateOn(FuzzIndex, iValue).ToString());
                }
                else
                {
                    // Try to convert to unsigned Int64
                    UInt64 uiValue = 0;
                    if (!UInt64.TryParse(sNodeValue, out uiValue))
                    {
                        throw new SkipStateException();
                    }

                    oValuesEditor.ChangeValue(NodeIndex, OperateOn(FuzzIndex, uiValue).ToString());
                }
            }
            return true;
        }
    }
}
