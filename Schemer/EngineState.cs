using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Threading;
using System.Xml;
using System.Xml.XPath;
using Fuzzware.Common;
using Fuzzware.Common.DataSchema;
using Fuzzware.Common.XML;
using Fuzzware.Schemer.Fuzzers;
using Fuzzware.Schemas.AutoGenerated;

namespace Fuzzware.Schemer
{
    class SkipStateException : Exception
    {
        public SkipStateException()
            : base()
        {

        }
    }

    class SkipStateOutOfRangeException : SkipStateException
    {
        public SkipStateOutOfRangeException()
            : base()
        {

        }
    }

    class SkipStateNoAllCaseException : SkipStateException
    {
        public SkipStateNoAllCaseException()
            : base()
        {

        }
    }

    class SkipStateFuzzerInGroupFinished : SkipStateException
    {
        public SkipStateFuzzerInGroupFinished()
            : base()
        {

        }
    }

    class SkipStateOutOfMemoryException : SkipStateException
    {
        public SkipStateOutOfMemoryException()
            : base()
        {

        }
    }

    class EngineState
    {
        private ConfigData oConfigData;
        private PreCompData oPreComp;

        // Allow the fuzzing to be controlled
        public Mutex oControlMutex;
        // Keep track the of the schema element we are fuzzing
        private int SchemaObjectIndex;
        // Keep track of any end index
        private int EndSchemaObjectIndex;
        // The state should know the data pointers being fuzzed so it can get the unique node index to tell the user.
        private XPathObjectList oObjectInstanceList;
        // Keeps track of the state of the current fuzzer
        private IFuzzState oCurrentFuzzerState;
        // Are we in test mode
        bool bTestMode;
        // Is there a fuzzer currently fuzzing, as opposed to Schemer being in set-up or switching nodes
        bool bIsFuzzing;

        // Remember the start and end states
        StateType StartState;
        StateType EndState;
        bool bStartStateSpecified;
        bool bEndStateSpecified;

        public static String DefaultTestcaseName = "OutputWithoutFuzzing";

        // Record a state history
        public struct StateHistoryEntry
        {
            public DateTime Time;
            public XmlQualifiedName ObjectName;
            public int NodeIndex;
            public int FuzzIndex;
            public String StateDesc;
        }
        List<StateHistoryEntry> oHistory;

        public EngineState(ConfigData oConfigData, PreCompData oPreComp) : this(oConfigData, oPreComp, false)
        {
        }

        public EngineState(ConfigData oConfigData, PreCompData oPreComp, bool Testing)
        {
            this.oConfigData = oConfigData;
            this.oPreComp = oPreComp;
            bTestMode = Testing;
            bIsFuzzing = false;

            oControlMutex = new Mutex();
            oHistory = new List<StateHistoryEntry>();
        }

        /// <summary>
        /// Initialise the state to its initial value, which could be set to a specific start state.  Will also take note of any specified
        /// end state.
        /// </summary>
        public void Initialise()
        {
            // We start fuzzing at 0, this can be changed by setting a start state
            SchemaObjectIndex = 0;

            Configuration Config = oConfigData.Config;

            // We finish fuzzing at the last node, this can be changed by setting an end state
            EndSchemaObjectIndex = oPreComp.ObjectNodeList.Count - 1;
            
            // If we have start or end states, note them
            SetStartAndEndStates(Config.Input);
        }

        /// <summary>
        /// Initialise the state of the fuzzer.  This allows us to specify the start state.
        /// </summary>
        /// <param name="oFuzzerState"></param>
        public void InitialiseFuzzerState(IFuzzState oFuzzerState)
        {
            oCurrentFuzzerState = oFuzzerState;
            bIsFuzzing = true;

            // Initialise the fuzzer, and then set bStartStateSpecified to false, so we don't initialise the next fuzzer
            if (bStartStateSpecified)
            {
                // This is our first opportunity to change the Node Index to be relative.  We would like to do this in 
                // SetStartAndEndStates, but we can't (see comments there).
                // StartState.Index is currently the absolute index into ObjectInstanceList of the Node to start at, so get its XPathNavigator
                // and use ObjectInstanceList.RelativeNodeIndex to get its relative index.
                if (!StartState.Index.Equals("All") && !oObjectInstanceList.NodeNameUnique())
                {
                    int iNodeIndex = 0;
                    if(Int32.TryParse(StartState.Index, out iNodeIndex))  // If this fails IFuzzState.SetState will flag the bad Node Index
                        StartState.Index = oObjectInstanceList.RelativeNodeIndex(oObjectInstanceList.XPathFromAbsoluteIndex(iNodeIndex)).ToString();
                }

                oFuzzerState.SetState(StartState.Index, StartState.FuzzerType, StartState.FuzzerIndex);
                bStartStateSpecified = false;
            }
            if ((SchemaObjectIndex == EndSchemaObjectIndex) && bEndStateSpecified)
            {
                // Same as above.
                if (!EndState.Index.Equals("All") && !oObjectInstanceList.NodeNameUnique())
                    EndState.Index = oObjectInstanceList.RelativeNodeIndex(oObjectInstanceList.XPathFromAbsoluteIndex(Int32.Parse(EndState.Index))).ToString();

                oFuzzerState.SetEndState(EndState.Index, EndState.FuzzerType, EndState.FuzzerIndex);
            }
        }

        /// <summary>
        /// Called after a node has finished fuzzing.
        /// </summary>
        public void FinialiseFuzzerState()
        {
            oCurrentFuzzerState = null;
            bIsFuzzing = false;
        }

        /// <summary>
        /// Gets the current IFuzzState
        /// </summary>
        public IFuzzState CurrentFuzzerState
        {
            get { return oCurrentFuzzerState; }
        }

        /// <summary>
        /// Moves the current state to the next state.  This will move to the next schema element.
        /// </summary>
        /// <returns></returns>
        public bool NextState()
        {
            if (SchemaObjectIndex < EndSchemaObjectIndex)
            {
                SchemaObjectIndex++;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Returns the current ElementDBEntry being fuzzed
        /// </summary>
        public ObjectDBEntry CurrentSchemaObject
        {
            get
            {
                if ((SchemaObjectIndex >= 0) && (SchemaObjectIndex < oPreComp.ObjectNodeList.Count))
                    return oPreComp.ObjectDB[oPreComp.ObjectNodeList[SchemaObjectIndex]];
                return null;
            }
        }

        /// <summary>
        /// Gets the index of the schema object currently being fuzzed
        /// </summary>
        public int CurrentSchemaObjectIndex
        {
            get { return SchemaObjectIndex; }
        }

        /// <summary>
        /// Returns the current XMLElementIdentifier for the current state
        /// </summary>
        public XMLObjectIdentifier CurrentObjectId
        {
            get
            {
                if ((SchemaObjectIndex >= 0) && (SchemaObjectIndex < oPreComp.ObjectNodeList.Count))
                    return oPreComp.ObjectNodeList[SchemaObjectIndex];
                return null;
            }
        }

        /// <summary>
        /// Sets the list of elements discovered in the XML
        /// </summary>
        public XPathObjectList ObjectInstanceList
        {
            set
            {
                oObjectInstanceList = value;
            }
        }

        /// <summary>
        /// Returns the mutex used to control the core dispatch routine.
        /// </summary>
        public Mutex ControlMutex
        {
            get { return oControlMutex; }
        }

        /// <summary>
        /// Indicates if a start state was specified
        /// </summary>
        public bool StartStateSpecified()
        {
            return bStartStateSpecified;
        }

        /// <summary>
        /// Set any start or end state
        /// </summary>
        private void SetStartAndEndStates(Input oInput)
        {
            bStartStateSpecified = false;
            bEndStateSpecified = false;
            if (null != oInput.StartState)
            {
                SchemaObjectIndex = GetObjectIndex(oInput.StartState);
                // Make sure the start index was found
                if (-1 == SchemaObjectIndex)
                    SchemaObjectIndex = 0;
                else
                {
                    // Start index successfully found
                    StartState = oInput.StartState;
                    bStartStateSpecified = true;
                    String StateStr = (String.IsNullOrEmpty(StartState.NamespacePrefix) ? "" : (StartState.NamespacePrefix + "-")) +
                        StartState.Name + "-" + StartState.Index + "-" + StartState.FuzzerType + "-" + StartState.FuzzerIndex;
                    Log.Write(MethodBase.GetCurrentMethod(), "Initial state of fuzzer: " + StateStr, Log.LogType.Status);
                    // The NodeIndex is absolute, the index is the index amongst all nodes that have that name even if they are
                    // of different types.  We need to change the NodeIndex to be relative, however we can't do it here since we 
                    // need to figure it out based on the XML, but at this stage we haven't read in the XML.  We therefore make 
                    // the change in InitialiseFuzzerState.
                }
            }
            if (null != oInput.EndState)
            {
                EndSchemaObjectIndex = GetObjectIndex(oInput.EndState);
                // Make sure an end index was found
                if (-1 == EndSchemaObjectIndex)
                    EndSchemaObjectIndex = oPreComp.ObjectNodeList.Count;
                // Make sure the end index is not before the start index
                else if (bStartStateSpecified && (SchemaObjectIndex > EndSchemaObjectIndex))
                {
                    EndSchemaObjectIndex = oPreComp.ObjectNodeList.Count;
                    Log.Write(MethodBase.GetCurrentMethod(), "The given end state occurs before the start state, ignoring", Log.LogType.Warning);
                    return;
                }
                else
                {
                    // End index successfully set
                    EndState = oInput.EndState;
                    bEndStateSpecified = true;
                    String StateStr = (String.IsNullOrEmpty(EndState.NamespacePrefix) ? "" : (EndState.NamespacePrefix + "-")) +
                        EndState.Name + "-" + EndState.Index + "-" + EndState.FuzzerType + "-" + EndState.FuzzerIndex;
                    Log.Write(MethodBase.GetCurrentMethod(), "Final state of fuzzer will be: " + StateStr, Log.LogType.Status);
                }
            }   
        }

        /// <summary>
        /// Returns the index into ObjectNodeList of the StateType node.
        /// </summary>
        private int GetObjectIndex(StateType oStateType)
        {
            bool StateIsAttribute = false;
            if (oStateType.Name.StartsWith("@"))
            {
                oStateType.Name = oStateType.Name.Remove(0, 1);
                StateIsAttribute = true;
            }
            // Set the initial node
            String[] Namespaces = XMLHelper.GetNamespacesFromPrefix(oPreComp.NamespacePrefixDict, oStateType.NamespacePrefix);
            XmlQualifiedName QName = null;
            XMLObjectIdentifier QNameId = null;
            for(int i = 0; i < Namespaces.Length; i++)
            {
                QName = new XmlQualifiedName(oStateType.Name, Namespaces[i]);
                // Try to find the element identifier
                if ((oPreComp.ObjectDB[QName]).Length > 0)
                {
                    break;
                }
                QName = null;
            }
            if (null == QName)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "No nodes/attributes of prefix '" + oStateType.NamespacePrefix + "' and name '" + 
                    oStateType.Name + "' were found to use as the specified start/end node, ignoring", Log.LogType.Warning);
                return -1;
            }
            // If only one exists then we found it
            else if ((oPreComp.ObjectDB[QName]).Length == 1)
            {
                QNameId = oPreComp.ObjectDB[QName][0].ObjectId;
            }
            // Need to do some more work to find it
            else if (((oPreComp.ObjectDB[QName]).Length > 1) && (!oStateType.Index.Equals("All")))
            {
                // Select all nodes with this XmlQualifiedName
                int NodeIndex = Int32.Parse(oStateType.Index);
                XPathNavigator[] XPathNavs = null;
                if (!StateIsAttribute)
                    XPathNavs = XMLHelper.SelectElementsOfType(QName, oPreComp.XMLDoc, oPreComp.NamespacePrefixDict);
                else
                    XPathNavs = XMLHelper.SelectAttributesOfType(QName, oPreComp.XMLDoc, oPreComp.NamespacePrefixDict);
                if (NodeIndex > XPathNavs.Length - 1)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "The NodeIndex of '" + oStateType.Index + "' was not possible for '" + QName + "', ignoring", Log.LogType.Warning);
                    return -1;
                }
                else
                {
                    // The node index should be unique so we can use it to recover the correct node identifier
                    if (StateIsAttribute)
                        QNameId = new XMLAttributeIdentifier(QName, XPathNavs[NodeIndex].SchemaInfo.SchemaAttribute, oPreComp.SchemaSet);
                    else
                        QNameId = new XMLElementIdentifier(QName, XPathNavs[NodeIndex].SchemaInfo.SchemaElement, oPreComp.SchemaSet);
                }
            }
            else if (oStateType.Index.Equals("All"))
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Cannot accurately set the start/end state, there is more than one possible choice for 'All', defaulting to first", Log.LogType.Warning);
                QNameId = oPreComp.ObjectDB[QName][0].ObjectId;
            }
            if (null != QNameId)
            {
                // Now that we have the ElementIdentifier, find it's index
                for (int i = 0; i < oPreComp.ObjectDB.ObjectIdList.Count; i++)
                    if (0 == QNameId.CompareTo(oPreComp.ObjectDB.ObjectIdList[i]))
                        return i;
                Log.Write(MethodBase.GetCurrentMethod(), "Could not find index of start/end state node, ignoring", Log.LogType.Warning);
            }
            return -1;
        }

        /// <summary>
        /// Records the history of the state.  Makes note what time the node changes or the fuzz index changes a large amount.
        /// </summary>
        public void RecordHistory()
        {
            lock (oHistory)
            {
                StateHistoryEntry Entry = new StateHistoryEntry();
                Entry.Time = DateTime.Now;
                Entry.ObjectName = CurrentSchemaObject.Name;
                //Entry.NodeIndex = iNodeIndex;
                if (oCurrentFuzzerState.NodeIndex == -1)
                    Entry.NodeIndex = oCurrentFuzzerState.NodeIndex;
                else
                    Entry.NodeIndex = oObjectInstanceList.UniqueNodeIndex(oObjectInstanceList[oCurrentFuzzerState.NodeIndex]);
                Entry.FuzzIndex = oCurrentFuzzerState.FuzzIndex;
                Entry.StateDesc = this.ToString();

                if (0 == oHistory.Count)
                {
                    oHistory.Add(Entry);
                    return;
                }

                StateHistoryEntry LastEntry = oHistory[oHistory.Count - 1];

                // Check if the node has changed
                if (Entry.ObjectName.ToString() == LastEntry.ObjectName.ToString())
                {
                    oHistory.Add(Entry);
                    return;
                }
                // Check if the fuzz index has changed by 1000.  We add 1 to account for the All(-1) fuzzing we did.
                int Factor = (oObjectInstanceList.Count > 1) ? oObjectInstanceList.Count + 1 : 1;
                if (Entry.FuzzIndex >= LastEntry.FuzzIndex + 1000 / Factor)
                {
                    oHistory.Add(Entry);
                    return;
                }
            }
        }

        /// <summary>
        /// Prints out the history.  Shows PrevStatesToShow states before Time.
        /// </summary>
        public void PrintHistory(DateTime Time, int PrevStatesToShow)
        {
            lock (oHistory)
            {
                int MatchingState = -1;
                // Find the index of the first state DateTime greater than the Time passed in
                for (int i = oHistory.Count - 1; i >= 0; i--)
                {
                    // Is the History value less than the Time value
                    if (oHistory[i].Time.CompareTo(Time) < 0)
                    {
                        MatchingState = i + 1;
                        break;
                    }
                }

                if (-1 == MatchingState)
                    return;
                if (MatchingState > oHistory.Count - 1)
                    MatchingState = oHistory.Count - 1;

                // Create desciption of previous states
                StringBuilder HistDesc = new StringBuilder();
                HistDesc.AppendLine("Showing previous " + PrevStatesToShow + " recorded states occurring before " + Time.ToShortDateString() + " " + Time.ToLongTimeString());
                for (int i = 0; (i < PrevStatesToShow) && (MatchingState - i > 0); i++)
                {
                    HistDesc.Append("\t\t");
                    HistDesc.AppendLine(oHistory[MatchingState - i].StateDesc);
                }
                Log.Write(MethodBase.GetCurrentMethod(), HistDesc.ToString(), Log.LogType.Info);
            }
        }

        /// <summary>
        /// Convert the state to a string.  This will attempt to find a prefix for the node of the current state.  It will also use
        /// an unique node index, to account for node with the same name.
        /// </summary>
        public override string ToString()
        {
            if (bTestMode)
                return EngineState.DefaultTestcaseName;

            StringBuilder StateString = new StringBuilder();

            // Set the element name
            if (null != CurrentSchemaObject)
            {
                // Get and add the prefix if there is one
                String prefix = "";
                oPreComp.NamespacePrefixDict.TryGetValue(CurrentSchemaObject.Name.Namespace, out prefix);
                if (!String.IsNullOrEmpty(prefix))
                    StateString.Append(prefix + "-");
                // If we are fuzzing an attribute add an '@'
                if (CurrentObjectId is XMLAttributeIdentifier)
                    StateString.Append("@");
                // Add the name
                StateString.Append(this.CurrentSchemaObject.Name.Name);
                StateString.Append("-");
            }

            if (null != oCurrentFuzzerState)
            {
                // Set the NodeIndex
                if (oCurrentFuzzerState.NodeIndex == -1)
                    StateString.Append("All-");
                else  // Make sure we output the node index that is unique for all nodes of this name
                    StateString.Append(oObjectInstanceList.UniqueNodeIndex(oObjectInstanceList[oCurrentFuzzerState.NodeIndex]).ToString() + "-");

                // Set the FuzzCategory
                if (!String.IsNullOrEmpty(oCurrentFuzzerState.Type))
                    StateString.Append(oCurrentFuzzerState.Type + "-");

                // Set the FuzzIndex
                StateString.Append(((uint)oCurrentFuzzerState.FuzzIndex));
            }

            if (StateString[StateString.Length - 1] == '-')
                StateString.Remove(StateString.Length - 1, 1);

            return StateString.ToString();
        }

        /// <summary>
        /// Returns true if we are currently fuzzing an attribute
        /// </summary>
        public bool FuzzingAttribute
        {
            get
            {
                if (CurrentObjectId is XMLAttributeIdentifier)
                    return true;
                return false;
                ;
            }
        }

        /// <summary>
        /// Returns true if a node is actively being fuzzed
        /// </summary>
        public bool IsFuzzing
        {
            get { return bIsFuzzing; }
        }
    }
}
