using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Input;
using System.ComponentModel;
using Fuzzware.Fuzzsaw.Common;
using Fuzzware.Schemas.AutoGenerated;

namespace Fuzzware.Fuzzsaw.Common.ViewModel
{
    public class ExeOutputControlViewModel : ViewModelBase, IDataErrorInfo
    {
        #region Dependency Properties
        static readonly DependencyProperty OpenActionsProperty = DependencyProperty.Register("OpenActions", typeof(ObservableCollection<WindowActionsViewModel>), typeof(ExeOutputControlViewModel));
        public ObservableCollection<WindowActionsViewModel> OpenActions
        {
            get { return (ObservableCollection<WindowActionsViewModel>)GetValue(OpenActionsProperty); }
            set { SetValue(OpenActionsProperty, value); }
        }

        static readonly DependencyProperty CloseActionsProperty = DependencyProperty.Register("CloseActions", typeof(ObservableCollection<WindowActionsViewModel>), typeof(ExeOutputControlViewModel));
        public ObservableCollection<WindowActionsViewModel> CloseActions
        {
            get { return (ObservableCollection<WindowActionsViewModel>)GetValue(CloseActionsProperty); }
            set { SetValue(CloseActionsProperty, value); }
        }

        static readonly DependencyProperty OpenDelayProperty = DependencyProperty.Register("OpenDelay", typeof(string), typeof(ExeOutputControlViewModel));
        public string OpenDelay
        {
            get { return (string)GetValue(OpenDelayProperty); }
            set { SetValue(OpenDelayProperty, value); }
        }

        static readonly DependencyProperty ProcessDelayProperty = DependencyProperty.Register("ProcessDelay", typeof(string), typeof(ExeOutputControlViewModel));
        public string ProcessDelay
        {
            get { return (string)GetValue(ProcessDelayProperty); }
            set { SetValue(ProcessDelayProperty, value); }
        }

        static readonly DependencyProperty CloseDelayProperty = DependencyProperty.Register("CloseDelay", typeof(string), typeof(ExeOutputControlViewModel));
        public string CloseDelay
        {
            get { return (string)GetValue(CloseDelayProperty); }
            set { SetValue(CloseDelayProperty, value); }
        }

        static readonly DependencyProperty ExecutableProperty = DependencyProperty.Register("Executable", typeof(FileControlViewModel), typeof(ExeOutputControlViewModel));
        public FileControlViewModel Executable
        {
            get { return (FileControlViewModel)GetValue(ExecutableProperty); }
            set { SetValue(ExecutableProperty, value); }
        }

        static readonly DependencyProperty CommandLineProperty = DependencyProperty.Register("CommandLine", typeof(string), typeof(ExeOutputControlViewModel));
        public string CommandLine
        {
            get { return (string)GetValue(CommandLineProperty); }
            set { SetValue(CommandLineProperty, value); }
        }

        static readonly DependencyProperty ExampleCommandLineProperty = DependencyProperty.Register("ExampleCommandLine", typeof(string), typeof(ExeOutputControlViewModel));
        public string ExampleCommandLine
        {
            get { return (string)GetValue(ExampleCommandLineProperty); }
            set { SetValue(ExampleCommandLineProperty, value); }
        }

        static readonly DependencyProperty UseConstantFilenameProperty = DependencyProperty.Register("UseConstantFilename", typeof(bool), typeof(ExeOutputControlViewModel));
        public bool UseConstantFilename
        {
            get { return (bool)GetValue(UseConstantFilenameProperty); }
            set { SetValue(UseConstantFilenameProperty, value); }
        }

        static readonly DependencyProperty FileStoreProperty = DependencyProperty.Register("FileStore", typeof(FileStoreControlViewModel), typeof(ExeOutputControlViewModel));
        public FileStoreControlViewModel FileStore
        {
            get { return (FileStoreControlViewModel)GetValue(FileStoreProperty); }
            set { SetValue(FileStoreProperty, value); }
        }
        #endregion

        #region Commands

        #region AddOpenWindowAction
        RelayCommand m_oAddOpenWindowActionCommand;

        public ICommand AddOpenWindowActionCommand
        {
            get
            {
                if (null == m_oAddOpenWindowActionCommand)
                    m_oAddOpenWindowActionCommand = new RelayCommand(AddOpenWindowActionExecute);
                return m_oAddOpenWindowActionCommand;
            }
        }

        public void AddOpenWindowActionExecute()
        {
            WindowActionsViewModel oWindowAction = new WindowActionsViewModel(new WindowAction());
            oWindowAction.Delete = RemoveWindowActionCommand;
            OpenActions.Add(oWindowAction);
        }
        #endregion

        #region AddCloseWindowAction
        RelayCommand m_oAddCloseWindowActionCommand;

        public ICommand AddCloseWindowActionCommand
        {
            get
            {
                if (null == m_oAddCloseWindowActionCommand)
                    m_oAddCloseWindowActionCommand = new RelayCommand(AddCloseWindowActionExecute);
                return m_oAddCloseWindowActionCommand;
            }
        }

        public void AddCloseWindowActionExecute()
        {
            WindowActionsViewModel oWindowAction = new WindowActionsViewModel(new WindowAction());
            oWindowAction.Delete = RemoveWindowActionCommand;
            CloseActions.Add(oWindowAction);
        }
        #endregion

        #region RemoveWindowAction
        RelayCommand<WindowActionsViewModel> m_oRemoveWindowActionCommand;

        public ICommand RemoveWindowActionCommand
        {
            get
            {
                if (null == m_oRemoveWindowActionCommand)
                    m_oRemoveWindowActionCommand = new RelayCommand<WindowActionsViewModel>(RemoveWindowActionExecute);
                return m_oRemoveWindowActionCommand;
            }
        }

        public void RemoveWindowActionExecute(WindowActionsViewModel WindowAction)
        {
            if (OpenActions.Contains(WindowAction))
                OpenActions.Remove(WindowAction);
            if (CloseActions.Contains(WindowAction))
                CloseActions.Remove(WindowAction);
        }
        #endregion

        #endregion

        /// <summary>
        /// Create the View Model for the Exe Output Control
        /// </summary>
        public ExeOutputControlViewModel()
        {
            Executable = new FileControlViewModel();
            Executable.Title = "Select an executable";
            Executable.DefaultExtension = ".exe";
            Executable.Filter = "EXE files (.exe)|*.exe";
            Executable.UseRelativePaths = false;

            OpenActions = new ObservableCollection<WindowActionsViewModel>();
            CloseActions = new ObservableCollection<WindowActionsViewModel>();

            CommandLine = "\"[workingdir]\\[filename]\"";

            OpenDelay = "1000";
            ProcessDelay = "1000";
            CloseDelay = "1000";

            FileStore = new FileStoreControlViewModel();
            FileStore.DirectoryName = Fuzzsaw.DefaultOutputDir;
            FileStore.FileExtension = Fuzzsaw.DefaultOutputExt;

            AddPropertyChangedEvents();
        }

        /// <summary>
        /// Create the wrapper object from an OutputToExe one
        /// </summary>
        public ExeOutputControlViewModel(OutputToExe oOutputToExe)
            : this()
        {
            if (null == oOutputToExe)
                return;

            if ((null != oOutputToExe.ExeOpenActions) && (null != oOutputToExe.ExeOpenActions.OpenWindowAction))
                for (int i = 0; i < oOutputToExe.ExeOpenActions.OpenWindowAction.Length; i++)
                {
                    WindowActionsViewModel oWindowActionsWrapper = new WindowActionsViewModel(oOutputToExe.ExeOpenActions.OpenWindowAction[i]);
                    oWindowActionsWrapper.Delete = RemoveWindowActionCommand;
                    OpenActions.Add(oWindowActionsWrapper);
                }

            if ((null != oOutputToExe.ExeCloseActions) && (null != oOutputToExe.ExeCloseActions.CloseWindowAction))
                for (int i = 0; i < oOutputToExe.ExeCloseActions.CloseWindowAction.Length; i++)
                {
                    WindowActionsViewModel oWindowActionsWrapper = new WindowActionsViewModel(oOutputToExe.ExeCloseActions.CloseWindowAction[i]);
                    oWindowActionsWrapper.Delete = RemoveWindowActionCommand;
                    CloseActions.Add(oWindowActionsWrapper);
                }

            if (null != oOutputToExe.ExeOpenActions)
                OpenDelay = oOutputToExe.ExeOpenActions.OpenDelayMilliSecs.ToString();

            ProcessDelay = oOutputToExe.ProcessDelay.ToString();

            if (null != oOutputToExe.ExeCloseActions)
                CloseDelay = oOutputToExe.ExeCloseActions.CloseDelayMilliSecs.ToString();

            if (null != oOutputToExe.ExePathAndName)
            {
                Executable.Filename = oOutputToExe.ExePathAndName.Value;
            }

            if (null != oOutputToExe.CommandLineParameters)
            {
                CommandLine = oOutputToExe.CommandLineParameters.Value;
                UseConstantFilename = oOutputToExe.CommandLineParameters.SingleTestcaseFilename;
            }

            // The testcase should have the InputFromFile file extension
            if (null != oOutputToExe.InputFromFile)
                FileStore.FileExtension = oOutputToExe.InputFromFile.FileExtension;

            // Both the testcase and the unique output should come from the UniqueOutputs dir
            if (null != oOutputToExe.UniqueOutputs)
            {
                FileStore.DirectoryName = oOutputToExe.UniqueOutputs.Directory;
                //FileStore.FileExtension = oOutputToExe.UniqueOutputs.FileExtension;
                FileStore.Tolerance = oOutputToExe.UniqueOutputs.Tolerance;
            }
        }

        /// <summary>
        /// To be able to update the example command line, assign property change event handlers to the relevant properties
        /// </summary>
        protected void AddPropertyChangedEvents()
        {
            PropertyChanged += new PropertyChangedEventHandler(CommandlineChangedEventHandler);
            DependencyPropertyDescriptor prop = DependencyPropertyDescriptor.FromProperty(FileControlViewModel.FilenameProperty, typeof(FileControlViewModel));
            prop.AddValueChanged(Executable, delegate { OnPropertyChanged(ExecutableProperty.Name); });
            prop = DependencyPropertyDescriptor.FromProperty(CommandLineProperty, typeof(ExeOutputControlViewModel));
            prop.AddValueChanged(this, delegate { OnPropertyChanged(CommandLineProperty.Name); });
            prop = DependencyPropertyDescriptor.FromProperty(UseConstantFilenameProperty, typeof(ExeOutputControlViewModel));
            prop.AddValueChanged(this, delegate { OnPropertyChanged(UseConstantFilenameProperty.Name); });
            prop = DependencyPropertyDescriptor.FromProperty(DirectoryControlViewModel.DirectoryNameProperty, typeof(DirectoryControlViewModel));
            prop.AddValueChanged(FileStore, delegate { OnPropertyChanged(FileStoreProperty.Name); });
            prop = DependencyPropertyDescriptor.FromProperty(FileStoreControlViewModel.FileExtensionProperty, typeof(DirectoryControlViewModel));
            prop.AddValueChanged(FileStore, delegate { OnPropertyChanged(FileStoreProperty.Name); });

            OnPropertyChanged(ExecutableProperty.Name);
        }

        /// <summary>
        /// Sets the example command line, when the values that affect it change
        /// </summary>
        protected void CommandlineChangedEventHandler(Object sender, PropertyChangedEventArgs e)
        {
            if (!(e.PropertyName.Equals(ExecutableProperty.Name) ||
                e.PropertyName.Equals(UseConstantFilenameProperty.Name) ||
                e.PropertyName.Equals(CommandLineProperty.Name) ||
                e.PropertyName.Equals(FileStoreProperty.Name)))
                return;

            StringBuilder oCommandLine = new StringBuilder();
            oCommandLine.Append(Executable.Filename);

            String UserCommandLine = CommandLine;
            UserCommandLine = UserCommandLine.Replace("[workingdir]", Fuzzsaw.ProjectDirectory);

            String Filename = "nsp-firstname-0-StringLength-10";
            if (UseConstantFilename)
                Filename = "testcase";
            if (null != FileStore)
            {
                if (!String.IsNullOrEmpty(FileStore.DirectoryName))
                    Filename = System.IO.Path.Combine(FileStore.DirectoryName, Filename);
                if (!String.IsNullOrEmpty(FileStore.FileExtension))
                    Filename = System.IO.Path.ChangeExtension(Filename, FileStore.FileExtension);
            }
            UserCommandLine = UserCommandLine.Replace("[filename]", Filename);

            oCommandLine.Append(" ");
            oCommandLine.Append(UserCommandLine);

            ExampleCommandLine = oCommandLine.ToString();
        }

        /// <summary>
        /// Convert the wrapper back into an OutputToExe
        /// </summary>
        public OutputToExe GetOutputToExe()
        {
            OutputToExe oOutputToExe = new OutputToExe();
            oOutputToExe.ExePathAndName = new OutputToExeExePathAndName();
            oOutputToExe.ExePathAndName.Value = Executable.Filename;
            oOutputToExe.CommandLineParameters = new OutputToExeCommandLineParameters();
            oOutputToExe.CommandLineParameters.Value = CommandLine;
            oOutputToExe.CommandLineParameters.SingleTestcaseFilename = UseConstantFilename;

            uint delay = 0;
            if (UInt32.TryParse(ProcessDelay, out delay))
                oOutputToExe.ProcessDelay = delay;

            oOutputToExe.ExeOpenActions = new OutputToExeExeOpenActions();
            if (UInt32.TryParse(OpenDelay, out delay))
                oOutputToExe.ExeOpenActions.OpenDelayMilliSecs = delay;
            oOutputToExe.ExeOpenActions.OpenWindowAction = new WindowAction[OpenActions.Count];
            for (int i = 0; i < OpenActions.Count; i++)
            {
                oOutputToExe.ExeOpenActions.OpenWindowAction[i] = new WindowAction();
                oOutputToExe.ExeOpenActions.OpenWindowAction[i].WindowTitle = OpenActions[i].WindowTitle;
                oOutputToExe.ExeOpenActions.OpenWindowAction[i].KeyboardStrokes = new string[OpenActions[i].Keystrokes.Count];
                for (int j = 0; j < OpenActions[i].Keystrokes.Count; j++)
                    oOutputToExe.ExeOpenActions.OpenWindowAction[i].KeyboardStrokes[j] = OpenActions[i].Keystrokes[j].Keys;
            }

            oOutputToExe.ExeCloseActions = new OutputToExeExeCloseActions();
            if (UInt32.TryParse(CloseDelay, out delay))
                oOutputToExe.ExeCloseActions.CloseDelayMilliSecs = delay;
            oOutputToExe.ExeCloseActions.CloseWindowAction = new WindowAction[CloseActions.Count];
            for (int i = 0; i < CloseActions.Count; i++)
            {
                oOutputToExe.ExeCloseActions.CloseWindowAction[i] = new WindowAction();
                oOutputToExe.ExeCloseActions.CloseWindowAction[i].WindowTitle = CloseActions[i].WindowTitle;
                oOutputToExe.ExeCloseActions.CloseWindowAction[i].KeyboardStrokes = new string[CloseActions[i].Keystrokes.Count];
                for (int j = 0; j < CloseActions[i].Keystrokes.Count; j++)
                    oOutputToExe.ExeCloseActions.CloseWindowAction[i].KeyboardStrokes[j] = CloseActions[i].Keystrokes[j].Keys;
            }

            oOutputToExe.InputFromFile = new FileStore();
            oOutputToExe.InputFromFile.Directory = FileStore.DirectoryName;
            oOutputToExe.InputFromFile.FileExtension = FileStore.FileExtension;
            oOutputToExe.UniqueOutputs = new FileStoreWithTolerance();
            oOutputToExe.UniqueOutputs.Directory = FileStore.DirectoryName;
            //oOutputToExe.UniqueOutputs.FileExtension = FileStore.FileExtension;
            oOutputToExe.UniqueOutputs.FileExtension = "txt";
            oOutputToExe.UniqueOutputs.Tolerance = FileStore.Tolerance;

            return oOutputToExe;
        }

        #region IDataErrorInfo Members

        public string Error
        {
            get { throw new NotImplementedException(); }
        }

        public string this[string columnName]
        {
            get
            {
                String error = null;
                if (columnName.Equals("OpenDelay"))
                {
                    uint delay = 0;
                    if (!UInt32.TryParse(OpenDelay, out delay))
                        error = "Open Delay must be an unsigned integer";
                }
                else if (columnName.Equals("ProcessDelay"))
                {
                    uint delay = 0;
                    if (!UInt32.TryParse(ProcessDelay, out delay))
                        error = "Process Delay must be an unsigned integer";
                }
                else if (columnName.Equals("CloseDelay"))
                {
                    uint delay = 0;
                    if (!UInt32.TryParse(CloseDelay, out delay))
                        error = "Close Delay must be an unsigned integer";
                }
                return error;
            }
        }

        #endregion
    }
}
