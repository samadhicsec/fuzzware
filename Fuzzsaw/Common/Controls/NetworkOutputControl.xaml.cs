using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Net;
using System.ComponentModel;
using Fuzzware.Schemas.AutoGenerated;

namespace Fuzzware.Fuzzsaw.Common.Controls
{
    /// <summary>
    /// Interaction logic for NetworkOutputControl.xaml
    /// </summary>
    public partial class NetworkOutputControl : UserControl
    {
        #region Dependency Properties declaration and setup

        static readonly DependencyProperty OutputToNetworkProperty = DependencyProperty.Register("OutputToNetwork", typeof(OutputToNetwork), typeof(NetworkOutputControl));
        public OutputToNetwork OutputToNetwork
        {
            get 
            {
                OutputToNetwork oOutputToNetwork = (OutputToNetwork)GetValue(OutputToNetworkProperty);

                ushort port = 0;
                if (UInt16.TryParse(NetworkInfo.Port, out port))
                    oOutputToNetwork.Port = port;
                IPAddress oIPAddress = null;
                if (IPAddress.TryParse(NetworkInfo.Address, out oIPAddress))
                    oOutputToNetwork.Item = NetworkInfo.Address;
                else
                {
                    OutputToNetworkURI oOutputToNetworkURI = new OutputToNetworkURI();
                    oOutputToNetworkURI.Value = NetworkInfo.Address;
                    oOutputToNetworkURI.UseSSL = NetworkInfo.UseSSL;
                    oOutputToNetwork.Item = oOutputToNetworkURI;
                }
                return oOutputToNetwork;
            }
            set 
            {
                OutputToNetwork oOutputToNetwork = value;
                if (oOutputToNetwork.Item is string)
                    NetworkInfo.Address = oOutputToNetwork.Item as string;
                else if (oOutputToNetwork.Item is OutputToNetworkURI)
                {
                    NetworkInfo.Address = (oOutputToNetwork.Item as OutputToNetworkURI).Value;
                    NetworkInfo.UseSSL = (oOutputToNetwork.Item as OutputToNetworkURI).UseSSL;
                }
                NetworkInfo.Port = oOutputToNetwork.Port.ToString();

                SetValue(OutputToNetworkProperty, value); 
            }
        }

        static readonly DependencyProperty NetworkInfoProperty = DependencyProperty.Register("NetworkInfo", typeof(NetworkInfoWrapper), typeof(NetworkOutputControl));
        public NetworkInfoWrapper NetworkInfo
        {
            get { return (NetworkInfoWrapper)GetValue(NetworkInfoProperty); }
            set { SetValue(NetworkInfoProperty, value); }
        }

        #endregion

        public NetworkOutputControl()
        {
            InitializeComponent();

            NetworkInfo = new NetworkInfoWrapper();
            this.OutputToNetwork = new OutputToNetwork();
            
            ckbxUseSSL.Checked += new RoutedEventHandler(ckbxUseSSL_Changed);
            ckbxUseSSL.Unchecked += new RoutedEventHandler(ckbxUseSSL_Changed);
        }

        /// <summary>
        /// Do this so Address goes through validation every time the UseSSL checkbox value changes
        /// </summary>
        void ckbxUseSSL_Changed(object sender, RoutedEventArgs e)
        {
            String orig = NetworkInfo.Address;
            NetworkInfo.Address = NetworkInfo.Address + " ";
            NetworkInfo.Address = orig;
        }
    }

    public class NetworkInfoWrapper : DependencyObject, IDataErrorInfo
    {
        #region Dependency Properties declaration and setup

        static readonly DependencyProperty AddressProperty = DependencyProperty.Register("Address", typeof(string), typeof(NetworkInfoWrapper));
        public string Address
        {
            get { return (string)GetValue(AddressProperty); }
            set { SetValue(AddressProperty, value); }
        }

        static readonly DependencyProperty PortProperty = DependencyProperty.Register("Port", typeof(string), typeof(NetworkInfoWrapper));
        public string Port
        {
            get { return (string)GetValue(PortProperty); }
            set { SetValue(PortProperty, value); }
        }

        static readonly DependencyProperty UseSSLProperty = DependencyProperty.Register("UseSSL", typeof(bool), typeof(NetworkInfoWrapper));
        public bool UseSSL
        {
            get { return (bool)GetValue(UseSSLProperty); }
            set { SetValue(UseSSLProperty, value); }
        }

        #endregion

        #region IDataErrorInfo Members

        public string Error
        {
            get { throw new NotImplementedException(); }
        }

        public string this[string columnName]
        {
            get 
            {
                string error = null;

                if (columnName.Equals("Address"))
                {
                    IPAddress oIPAddress = null;
                    if (IPAddress.TryParse(Address, out oIPAddress) && UseSSL)
                        error = "SSL can only be used with host names, not IP addresses";    
                    if ((Uri.CheckHostName(Address) == UriHostNameType.Unknown) &&
                        !IPAddress.TryParse(Address, out oIPAddress))
                        error = "Not a valid host name or IP address";
                
                }
                else if (columnName.Equals("Port"))
                {
                    ushort num = 0;
                    if (!UInt16.TryParse(Port, out num))
                        error = "Port must be between 0 and 65535";
                }
                return error;
            }
        }

        #endregion
    }
}
