using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.ComponentModel;
using Fuzzware.Schemas.AutoGenerated;

namespace Fuzzware.Fuzzsaw.Common.Controls
{
    /// <summary>
    /// Interaction logic for ExeOutputControl.xaml
    /// </summary>
    public partial class ExeOutputControl : UserControl
    {
        #region Dependency Properties declaration and setup

        static readonly DependencyProperty ExeConfigurationProperty = DependencyProperty.Register("ExeConfiguration", typeof(OutputToExeWrapper), typeof(ExeOutputControl));
        public OutputToExeWrapper ExeConfiguration
        {
            get { return (OutputToExeWrapper)GetValue(ExeConfigurationProperty); }
            set { SetValue(ExeConfigurationProperty, value); }
        }

        #endregion

        public ExeOutputControl()
        {
            InitializeComponent();

            ExeConfiguration = new OutputToExeWrapper();
            
            tbCommandLine.TextChanged += new TextChangedEventHandler(UpdateExampleCommandLine);
            ckbxConstantFilename.Checked += new RoutedEventHandler(UpdateExampleCommandLine);
            ckbxConstantFilename.Unchecked += new RoutedEventHandler(UpdateExampleCommandLine);
            // TODO find a better way to know if these properties have changed
            ucExe.MouseLeave += new MouseEventHandler(UpdateExampleCommandLine);
            ucOutputDir.MouseLeave += new MouseEventHandler(UpdateExampleCommandLine);
        }

        /// <summary>
        /// Update the example command line so user can see what it will look like
        /// </summary>
        private void UpdateExampleCommandLine(object sender, object args)
        {
            StringBuilder oCommandLine = new StringBuilder();
            oCommandLine.Append(ucExe.Filename);

            String UserCommandLine = tbCommandLine.Text;
            UserCommandLine = UserCommandLine.Replace("[workingdir]", Fuzzsaw.ProjectDirectory);

            String Filename = "nsp-firstname-0-StringLength-10";
            if (true == ckbxConstantFilename.IsChecked)
                Filename = "testcase";
            if (null != ucOutputDir.FileStoreWithTolerance)
            {
                if (!String.IsNullOrEmpty(ucOutputDir.FileStoreWithTolerance.Directory))
                    Filename = System.IO.Path.Combine(ucOutputDir.FileStoreWithTolerance.Directory, Filename);
                if (!String.IsNullOrEmpty(ucOutputDir.FileStoreWithTolerance.FileExtension))
                    Filename = System.IO.Path.ChangeExtension(Filename, ucOutputDir.FileStoreWithTolerance.FileExtension);
            }
            UserCommandLine = UserCommandLine.Replace("[filename]", Filename);

            oCommandLine.Append(" ");
            oCommandLine.Append(UserCommandLine);

            txtExampleCommandLine.Text = oCommandLine.ToString();
        }

        /// <summary>
        /// Add an Open WindowAction
        /// </summary>
        private void OpenActionsAddWindowActions(object sender, RoutedEventArgs e)
        {
            ExeConfiguration.OpenActions.Add(new WindowActionsWrapper(new WindowAction()));
        }

        /// <summary>
        /// Add a Close WindowAction
        /// </summary>
        private void CloseActionsAddWindowActions(object sender, RoutedEventArgs e)
        {
            ExeConfiguration.CloseActions.Add(new WindowActionsWrapper(new WindowAction()));
        }

        /// <summary>
        /// Remove a WindowAction
        /// </summary>
        private void SubtractWindowActions(object sender, RoutedEventArgs e)
        {
            if(!(sender is FrameworkElement))
                return;
            // The DataContext should be the object we want to delete
            WindowActionsWrapper oWindowActionsWrapper = (sender as FrameworkElement).DataContext as WindowActionsWrapper;
            // Get the parent ItemsControl
            ItemsControl oItemsControl = (ItemsControl)Common.GetDependencyObjectFromVisualTree((sender as FrameworkElement), typeof(ItemsControl));
            if (null == oItemsControl)
                return;
            // Get the items source
            ObservableCollection<WindowActionsWrapper> oActions = oItemsControl.ItemsSource as ObservableCollection<WindowActionsWrapper>;
            if (null == oActions)
                return;
            // Find this WindowActionsWrapper
            for (int i = 0; i < oActions.Count; i++)
            {
                if (oWindowActionsWrapper == oActions[i])
                {
                    oActions.RemoveAt(i);
                    break;
                }
            }
        }

        /// <summary>
        /// When the mouse is in the Border and the users presses a key
        /// </summary>
        private void WindowActionKeystroke(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.System)
                return;
            // Since the Modifier key are detected as key presses, we ignore these
            switch (e.Key)
            {
                case Key.LeftAlt:
                case Key.LeftCtrl:
                case Key.LeftShift:
                case Key.RightAlt:
                case Key.RightCtrl:
                case Key.RightShift:
                    return;
            }

            Border oBorder = sender as Border;
            TextBox oTextBox = e.OriginalSource as TextBox;
            // Make sure the Border initiated this event and not a TextBox
            if ((null != oBorder) && (oBorder.IsMouseOver) && (oTextBox == null))
            {
                // The DataContext should be the object we want to add too
                WindowActionsWrapper oWindowActionsWrapper = oBorder.DataContext as WindowActionsWrapper;
                
                if (0 == oWindowActionsWrapper.Keystrokes.Count)
                    oWindowActionsWrapper.Keystrokes.Add(new ObservableString(""));

                // Get the last stored keystroke
                ObservableString oLastKeyStroke = oWindowActionsWrapper.Keystrokes[oWindowActionsWrapper.Keystrokes.Count - 1];
                bool bLastKeyIsSpecial = false;
                if (-1 != oLastKeyStroke.Value.IndexOfAny(new char[] { '{', '+', '^', '%' }))
                    bLastKeyIsSpecial = true;
                // Get the current keystroke
                bool bNewKeyIsSpecial = false;
                String NewKey = KeystrokeToAdd(e, out bNewKeyIsSpecial);

                if (!bLastKeyIsSpecial && !bNewKeyIsSpecial)
                {
                    oLastKeyStroke.Value = oLastKeyStroke.Value + NewKey;
                    return;
                }
                else
                {
                    // Add this Key
                    if(String.IsNullOrEmpty(oLastKeyStroke.Value))
                        oWindowActionsWrapper.Keystrokes[oWindowActionsWrapper.Keystrokes.Count - 1] = new ObservableString(NewKey);
                    else
                        oWindowActionsWrapper.Keystrokes.Add(new ObservableString(NewKey));
                }
            }
        }

        private String KeystrokeToAdd(KeyEventArgs e, out bool bIsSpecial)
        {
            KeyConverter oKeyConverter = new KeyConverter();
            bIsSpecial = false;

            String KeyStr = oKeyConverter.ConvertToString(e.Key);
            // Conversion to something System.Windows.Forms.SendKeys can understand
            switch (e.Key)
            {
                case Key.Return:
                    KeyStr = "ENTER";
                    break;
                case Key.Escape:
                    KeyStr = "ESC";
                    break;
                case Key.PageDown:
                    KeyStr = "PGDN";
                    break;
                case Key.PageUp:
                    KeyStr = "PGUP";
                    break;
                case Key.Space:
                    KeyStr = " ";
                    break;
            }
            KeyStr = KeyStr.ToUpper();

            if (KeyStr.Length > 1)
            {
                KeyStr = "{" + KeyStr + "}";
                bIsSpecial = true;
            }
            else if (e.KeyboardDevice.Modifiers != ModifierKeys.Shift)
            {
                // Keys are always in upper case
                KeyStr = KeyStr.ToLower();
            }
            switch (e.Key)
            {
                case Key.Add:
                case Key.OemPlus:
                    KeyStr = "{+}";
                    break;
                default:
                    break;
            }

            // Get Modifier
            String Modifier = "";
            if (e.KeyboardDevice.Modifiers == ModifierKeys.Shift)
                Modifier += "+";
            if (e.KeyboardDevice.Modifiers == ModifierKeys.Control)
                Modifier += "^";
            if (e.KeyboardDevice.Modifiers == ModifierKeys.Alt)
                Modifier += "%";
            if (!String.IsNullOrEmpty(Modifier))
                bIsSpecial = true;

            return Modifier + KeyStr;
        }

        private void Border_MouseEnter(object sender, MouseEventArgs e)
        {
            if(sender is Border)
                Keyboard.Focus(sender as Border);
        }

        private void RemoveKeyStroke(object sender, RoutedEventArgs e)
        {
            if (!(sender is FrameworkElement))
                return;

            // Get the DataContext for the sender
            ObservableString oOString = (ObservableString)(sender as FrameworkElement).DataContext;
            if (null == oOString)
                return;

            // Find parent that is ItemsControl
            ItemsControl oItems = (ItemsControl)Common.GetDependencyObjectFromVisualTree(sender as DependencyObject, typeof(ItemsControl));
            if (null == oItems)
                return;

            // Get DataContext of ItemsControl
            WindowActionsWrapper oWindowActionsWrapper = (WindowActionsWrapper)oItems.DataContext;
            if (null == oWindowActionsWrapper)
                return;

            // Find the ObservableString and remove it
            for(int i = 0; i < oWindowActionsWrapper.Keystrokes.Count; i++)
                if (oWindowActionsWrapper.Keystrokes[i] == oOString)
                {
                    oWindowActionsWrapper.Keystrokes.RemoveAt(i);
                    break;
                }
        }


    }

    public class OutputToExeWrapper : DependencyObject, IDataErrorInfo
    {
        #region Dependency Properties declaration and setup

        static readonly DependencyProperty OpenActionsProperty = DependencyProperty.Register("OpenActions", typeof(ObservableCollection<WindowActionsWrapper>), typeof(OutputToExeWrapper));
        public ObservableCollection<WindowActionsWrapper> OpenActions
        {
            get { return (ObservableCollection<WindowActionsWrapper>)GetValue(OpenActionsProperty); }
            set { SetValue(OpenActionsProperty, value); }
        }

        static readonly DependencyProperty CloseActionsProperty = DependencyProperty.Register("CloseActions", typeof(ObservableCollection<WindowActionsWrapper>), typeof(OutputToExeWrapper));
        public ObservableCollection<WindowActionsWrapper> CloseActions
        {
            get { return (ObservableCollection<WindowActionsWrapper>)GetValue(CloseActionsProperty); }
            set { SetValue(CloseActionsProperty, value); }
        }

        static readonly DependencyProperty OpenDelayProperty = DependencyProperty.Register("OpenDelay", typeof(string), typeof(OutputToExeWrapper));
        public string OpenDelay
        {
            get { return (string)GetValue(OpenDelayProperty); }
            set { SetValue(OpenDelayProperty, value); }
        }

        static readonly DependencyProperty ProcessDelayProperty = DependencyProperty.Register("ProcessDelay", typeof(string), typeof(OutputToExeWrapper));
        public string ProcessDelay
        {
            get { return (string)GetValue(ProcessDelayProperty); }
            set { SetValue(ProcessDelayProperty, value); }
        }

        static readonly DependencyProperty CloseDelayProperty = DependencyProperty.Register("CloseDelay", typeof(string), typeof(OutputToExeWrapper));
        public string CloseDelay
        {
            get { return (string)GetValue(CloseDelayProperty); }
            set { SetValue(CloseDelayProperty, value); }
        }

        static readonly DependencyProperty ExecutableProperty = DependencyProperty.Register("Executable", typeof(string), typeof(OutputToExeWrapper));
        public string Executable
        {
            get { return (string)GetValue(ExecutableProperty); }
            set { SetValue(ExecutableProperty, value); }
        }

        static readonly DependencyProperty CommandLineProperty = DependencyProperty.Register("CommandLine", typeof(string), typeof(OutputToExeWrapper));
        public string CommandLine
        {
            get { return (string)GetValue(CommandLineProperty); }
            set { SetValue(CommandLineProperty, value); }
        }

        static readonly DependencyProperty UseConstantFilenameProperty = DependencyProperty.Register("UseConstantFilename", typeof(bool), typeof(OutputToExeWrapper));
        public bool UseConstantFilename
        {
            get { return (bool)GetValue(UseConstantFilenameProperty); }
            set { SetValue(UseConstantFilenameProperty, value); }
        }

        static readonly DependencyProperty FileStoreWithToleranceProperty = DependencyProperty.Register("FileStoreWithTolerance", typeof(FileStoreWithTolerance), typeof(OutputToExeWrapper));
        public FileStoreWithTolerance FileStoreWithTolerance
        {
            get { return (FileStoreWithTolerance)GetValue(FileStoreWithToleranceProperty); }
            set { SetValue(FileStoreWithToleranceProperty, value); }
        }
        #endregion

        /// <summary>
        /// Create the wrapper object with default values
        /// </summary>
        public OutputToExeWrapper()
        {
            OpenActions = new ObservableCollection<WindowActionsWrapper>();
            CloseActions = new ObservableCollection<WindowActionsWrapper>();

            CommandLine = "\"[workingdir]\\[filename]\"";

            OpenDelay = "1000";
            ProcessDelay = "1000";
            CloseDelay = "1000";

            FileStoreWithTolerance = new FileStoreWithTolerance();
        }

        /// <summary>
        /// Create the wrapper object from an OutputToExe one
        /// </summary>
        public OutputToExeWrapper(OutputToExe oOutputToExe)
        {
            if (null == oOutputToExe)
                return;

            OpenActions = new ObservableCollection<WindowActionsWrapper>();
            if((null != oOutputToExe.ExeOpenActions) && (null != oOutputToExe.ExeOpenActions.OpenWindowAction))
                for (int i = 0; i < oOutputToExe.ExeOpenActions.OpenWindowAction.Length; i++)
                {
                    WindowActionsWrapper oWindowActionsWrapper = new WindowActionsWrapper(oOutputToExe.ExeOpenActions.OpenWindowAction[i]);
                    OpenActions.Add(oWindowActionsWrapper);
                }

            CloseActions = new ObservableCollection<WindowActionsWrapper>();
            if ((null != oOutputToExe.ExeCloseActions) && (null != oOutputToExe.ExeCloseActions.CloseWindowAction))
                for (int i = 0; i < oOutputToExe.ExeCloseActions.CloseWindowAction.Length; i++)
                {
                    WindowActionsWrapper oWindowActionsWrapper = new WindowActionsWrapper(oOutputToExe.ExeCloseActions.CloseWindowAction[i]);
                    CloseActions.Add(oWindowActionsWrapper);
                }

            if (null != oOutputToExe.ExeOpenActions)
                OpenDelay = oOutputToExe.ExeOpenActions.OpenDelayMilliSecs.ToString();

            ProcessDelay = oOutputToExe.ProcessDelay.ToString();

            if (null != oOutputToExe.ExeCloseActions)
                CloseDelay = oOutputToExe.ExeCloseActions.CloseDelayMilliSecs.ToString();

            if(null != oOutputToExe.ExePathAndName)
                Executable = oOutputToExe.ExePathAndName.Value;

            if (null != oOutputToExe.CommandLineParameters)
            {
                CommandLine = oOutputToExe.CommandLineParameters.Value;
                UseConstantFilename = oOutputToExe.CommandLineParameters.SingleTestcaseFilename;
            }

            FileStoreWithTolerance = oOutputToExe.UniqueOutputs;
        }

        /// <summary>
        /// Convert the wrapper back into an OutputToExe
        /// </summary>
        public OutputToExe GetOutputToExe()
        {
            OutputToExe oOutputToExe = new OutputToExe();
            oOutputToExe.ExePathAndName = new OutputToExeExePathAndName();
            oOutputToExe.ExePathAndName.Value = Executable;
            oOutputToExe.CommandLineParameters = new OutputToExeCommandLineParameters();
            oOutputToExe.CommandLineParameters.Value = CommandLine;
            oOutputToExe.CommandLineParameters.SingleTestcaseFilename = UseConstantFilename;

            uint delay = 0;
            if (UInt32.TryParse(ProcessDelay, out delay))
                oOutputToExe.ProcessDelay = delay;

            oOutputToExe.ExeOpenActions = new OutputToExeExeOpenActions();
            if (UInt32.TryParse(OpenDelay, out delay))
                oOutputToExe.ExeOpenActions.OpenDelayMilliSecs = delay;
            oOutputToExe.ExeOpenActions.OpenWindowAction = new WindowAction[OpenActions.Count];
            for (int i = 0; i < OpenActions.Count; i++)
            {
                oOutputToExe.ExeOpenActions.OpenWindowAction[i] = new WindowAction();
                oOutputToExe.ExeOpenActions.OpenWindowAction[i].WindowTitle = OpenActions[i].WindowTitle;
                oOutputToExe.ExeOpenActions.OpenWindowAction[i].KeyboardStrokes = new string[OpenActions[i].Keystrokes.Count];
                for (int j = 0; j < OpenActions[i].Keystrokes.Count; j++)
                    oOutputToExe.ExeOpenActions.OpenWindowAction[i].KeyboardStrokes[j] = OpenActions[i].Keystrokes[j].Value;
            }

            oOutputToExe.ExeCloseActions = new OutputToExeExeCloseActions();
            if (UInt32.TryParse(CloseDelay, out delay))
                oOutputToExe.ExeCloseActions.CloseDelayMilliSecs = delay;
            oOutputToExe.ExeCloseActions.CloseWindowAction = new WindowAction[CloseActions.Count];
            for (int i = 0; i < CloseActions.Count; i++)
            {
                oOutputToExe.ExeCloseActions.CloseWindowAction[i] = new WindowAction();
                oOutputToExe.ExeCloseActions.CloseWindowAction[i].WindowTitle = CloseActions[i].WindowTitle;
                oOutputToExe.ExeCloseActions.CloseWindowAction[i].KeyboardStrokes = new string[CloseActions[i].Keystrokes.Count];
                for (int j = 0; j < CloseActions[i].Keystrokes.Count; j++)
                    oOutputToExe.ExeCloseActions.CloseWindowAction[i].KeyboardStrokes[j] = CloseActions[i].Keystrokes[j].Value;
            }

            oOutputToExe.InputFromFile = FileStoreWithTolerance;
            oOutputToExe.UniqueOutputs = FileStoreWithTolerance;
            oOutputToExe.UniqueOutputs.FileExtension = "txt";

            return oOutputToExe;
        }

        #region IDataErrorInfo Members

        public string Error
        {
            get { throw new NotImplementedException(); }
        }

        public string this[string columnName]
        {
            get 
            {
                String error = null;
                if (columnName.Equals("OpenDelay"))
                {
                    uint delay = 0;
                    if (!UInt32.TryParse(OpenDelay, out delay))
                        error = "Open Delay must be an unsigned integer";
                }
                else if (columnName.Equals("ProcessDelay"))
                {
                    uint delay = 0;
                    if (!UInt32.TryParse(ProcessDelay, out delay))
                        error = "Process Delay must be an unsigned integer";
                }
                else if (columnName.Equals("CloseDelay"))
                {
                    uint delay = 0;
                    if (!UInt32.TryParse(CloseDelay, out delay))
                        error = "Close Delay must be an unsigned integer";
                }
                return error;
            }
        }

        #endregion
    }

    public class WindowActionsWrapper : DependencyObject, System.ComponentModel.IDataErrorInfo
    {
        #region Dependency Properties declaration and setup

        static readonly DependencyProperty WindowTitleProperty = DependencyProperty.Register("WindowTitle", typeof(string), typeof(WindowActionsWrapper));
        public string WindowTitle
        {
            get { return (string)GetValue(WindowTitleProperty); }
            set { SetValue(WindowTitleProperty, value); }
        }

        static readonly DependencyProperty KeystrokesProperty = DependencyProperty.Register("Keystrokes", typeof(ObservableCollection<ObservableString>), typeof(WindowActionsWrapper));
        public ObservableCollection<ObservableString> Keystrokes
        {
            get { return (ObservableCollection<ObservableString>)GetValue(KeystrokesProperty); }
            set { SetValue(KeystrokesProperty, value); }
        }

        #endregion

        public WindowActionsWrapper(WindowAction oWindowAction)
        {
            WindowTitle = oWindowAction.WindowTitle;
            Keystrokes = new ObservableCollection<ObservableString>();
            for (int i = 0; (null != oWindowAction.KeyboardStrokes) && (i < oWindowAction.KeyboardStrokes.Length); i++)
            {
                Keystrokes.Add(new ObservableString(oWindowAction.KeyboardStrokes[i]));
            }
        }

        #region IDataErrorInfo Members

        public string Error
        {
            get { throw new NotImplementedException(); }
        }

        public string this[string columnName]
        {
            get 
            { 
                if(columnName.Equals("WindowTitle"))
                {
                    if (String.IsNullOrEmpty(WindowTitle))
                        return "Window Title cannot be empty";
                }
                return null;
            }
        }

        #endregion
    }
}
