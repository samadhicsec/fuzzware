using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.XPath;
using System.Net;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Common.MethodInterface;
using Fuzzware.Evaluate.Statistics;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Convert2XML;

namespace Fuzzware.Evaluate
{
    class OutputToWebServiceHandler : OutputHandler
    {
        OutputToWebService oOutputToWebService;
        WSDLLibraryDescription oLibraryDesc;

        //OutputToNetworkHandler oOutputToNetworkHandler;

        XmlDocument oSOAPRequestXML;
        DateTime oTemplateLastModified;
        const String constSOAPNS = "%SOAPNAMESPACE%";
        const String constSOAP11NS = "http://schemas.xmlsoap.org/soap/envelope/";
        const String constSOAP12NS = "http://www.w3.org/2003/05/soap-envelope";
        XmlElement oBody;
        XmlNode oOldMethodBody;
        List<string> oParametersToReuseList;

        public override void Initialise(object Settings, Fuzzware.Convert2XML.InputHandler oInputHandler)
        {
            if (!(Settings is OutputToWebService))
                Log.Write(MethodInfo.GetCurrentMethod(), "Expected Settings object of type 'OutputToWebService', got '" + Settings.GetType().ToString() + "'", Log.LogType.Error);

            oOutputToWebService = Settings as OutputToWebService;

            if (String.IsNullOrEmpty(oOutputToWebService.UniqueResponses.Directory))
                oOutputToWebService.UniqueResponses.Directory = Environment.CurrentDirectory;

            // Get the library description
            if (!(oInputHandler is WSDLInputHandler))
                Log.Write(MethodInfo.GetCurrentMethod(), "To use the 'OutputToWebService', the input must come from 'WSDLInput'", Log.LogType.Error);
            
            oLibraryDesc = (oInputHandler as WSDLInputHandler).LibraryDesc;

            // Validate the SOAP Request template
            if (String.IsNullOrEmpty(oOutputToWebService.SOAPRequestTemplate))
            {
                // Use the default
#if DEBUG
                String ResourcesRelativePath = @"..\..\..\Resources";
#else
                String ResourcesRelativePath = @"Resources";
#endif
                oOutputToWebService.SOAPRequestTemplate = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), ResourcesRelativePath + Path.DirectorySeparatorChar + "SOAPRequestTemplate.xml"));
            }
            if (!File.Exists(Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate)))
            {
                Log.Write(MethodBase.GetCurrentMethod(), "SOAP Request template file '" +
                    Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate) + "' could not be found", Log.LogType.Error);
            }
            Log.Write(MethodBase.GetCurrentMethod(), "Using SOAP request template file '" + Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate) + "'", Log.LogType.Info);

            // Load the template SOAP Request class variables
            LoadTemplate();

            // Get the list of the Response parameters to reuse
            oParametersToReuseList = new List<string>();
            if (null != oOutputToWebService.ReuseResponseParameters)
                oParametersToReuseList = new List<string>(oOutputToWebService.ReuseResponseParameters);
            
            //oSOAPRequestXML = new XmlDocument();
            //try
            //{
            //    oSOAPRequestXML.Load(Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate));
            //}
            //catch (Exception e)
            //{
            //    Log.Write(MethodBase.GetCurrentMethod(), "An error occurred loading '" +
            //        Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate) + "': " + Environment.NewLine + e.Message, Log.LogType.Error);
            //}
            //// Get the Body element
            //XPathNavigator oXPathNav = XMLHelper.GetRootNode(oSOAPRequestXML);
            //// TODO how is the template going to account for the differences between SOAP1.1 and SOAP1.2
            //String prefix = oXPathNav.LookupPrefix("http://schemas.xmlsoap.org/soap/envelope/");
            //if(String.IsNullOrEmpty(prefix))
            //    Log.Write(MethodBase.GetCurrentMethod(), "Could not find namespace 'http://schemas.xmlsoap.org/soap/envelope/' in SOAP Request template", Log.LogType.Error);
            //XmlNamespaceManager oNSM = new XmlNamespaceManager(oXPathNav.NameTable);
            //oNSM.AddNamespace(prefix, "http://schemas.xmlsoap.org/soap/envelope/");
            //oBody = oSOAPRequestXML.SelectSingleNode(prefix + ":Envelope/" + prefix + ":Body", oNSM) as XmlElement;

            //if(null == oBody)
            //    Log.Write(MethodBase.GetCurrentMethod(), "Could not find Body node in SOAP Request template", Log.LogType.Error);

            //// Configure the output to network handler
            //OutputToNetwork oOutputToNetwork = new OutputToNetwork();
            //OutputToNetworkURI oURI = new OutputToNetworkURI();
            //oURI.Value = sLocation;
            //oURI.UseSSL = (oLocationURI.Scheme.Equals("https", StringComparison.CurrentCultureIgnoreCase)) ? true : false;
            //oOutputToNetwork.Item = oURI;
            //oOutputToNetwork.Port = oLocationURI.Port;
            //oOutputToNetwork.UniqueResponses = oOutputToWebService.UniqueResponses;

            //// Initialise the output to network handler
            //oOutputToNetworkHandler = new OutputToNetworkHandler();
            //oOutputToNetworkHandler.Initialise(oOutputToNetwork, null);
        }

        /// <summary>
        /// The template used for the SOAP request may be updated by a PreOutputHandler, so we check the modified time of
        /// the template file against the time we recorded when we first loaded the file todetermine if we should reload it.
        /// </summary>
        private void LoadTemplate()
        {
            // If we have previously loaded a template, check to see if it has changed
            if (null != oSOAPRequestXML)
            {
                if (File.Exists(Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate)))
                {
                    DateTime oLastModified = File.GetLastWriteTime(Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate));
                    if (oLastModified <= oTemplateLastModified)
                        // The file has not been modified since we loaded it
                        return;
                }
                else
                    Log.Write(MethodBase.GetCurrentMethod(), "The template '" + Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate) + "' does not exist", Log.LogType.Error);
            }

            // Load the file as a string so we can replace the SOAP namespace with the specified SOAP1.1 or SOAP1.2 one.
            String oSOAPRequestString;
            using (StreamReader sr = new StreamReader(Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate), true))
            {
                oSOAPRequestString = sr.ReadToEnd();
            }
            // Record the time the file was last modified
            oTemplateLastModified = File.GetLastWriteTime(Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate));

            // Set the correct SOAP namespace
            String SoapNS = (oLibraryDesc.Protocol == WSDLInputProtocol.Soap)?constSOAP11NS:constSOAP12NS;
            oSOAPRequestString = oSOAPRequestString.Replace(constSOAPNS, SoapNS);
            
            // Load the template SOAP Request into an XMlDocument
            oSOAPRequestXML = new XmlDocument();
            try
            {
                //oSOAPRequestXML.Load(Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate));
                oSOAPRequestXML.LoadXml(oSOAPRequestString);
            }
            catch (Exception e)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "An error occurred loading '" +
                    Path.GetFullPath(oOutputToWebService.SOAPRequestTemplate) + "': " + Environment.NewLine + e.Message, Log.LogType.Error);
            }
            
            // Get the Body element
            XPathNavigator oXPathNav = XMLHelper.GetRootNode(oSOAPRequestXML);

            String prefix = oXPathNav.LookupPrefix(SoapNS);
            if (String.IsNullOrEmpty(prefix))   // Means prefix cannot be empty string
                Log.Write(MethodBase.GetCurrentMethod(), "Could not find (non-empty) prefix for namespace '" + SoapNS + "' in SOAP Request template", Log.LogType.Error);
            
            XmlNamespaceManager oNSM = new XmlNamespaceManager(oXPathNav.NameTable);
            oNSM.AddNamespace(prefix, SoapNS);
            oBody = oSOAPRequestXML.SelectSingleNode(prefix + ":Envelope/" + prefix + ":Body", oNSM) as XmlElement;

            if (null == oBody)
                Log.Write(MethodBase.GetCurrentMethod(), "Could not find Body node in SOAP Request template", Log.LogType.Error);

            oOldMethodBody = null;
        }

        public override bool Output(System.IO.MemoryStream XMLMemoryStream, string StateDesc)
        {
            bool bContainsUniqueResponse = false;       // Will be true if at least one method response is unique

            // Convert the memory stream back into an XML document so we can navigate it
            XmlDocument oMethods = new XmlDocument();
            oMethods.Load(XMLMemoryStream);

            // Create the navigator
            XPathNavigator oXPathNav = XMLHelper.GetRootNode(oMethods);
            // Navigate to the first method
            if (!oXPathNav.MoveToFirstChild())
            {
                Log.Write(MethodBase.GetCurrentMethod(), "There were no methods to call.", Log.LogType.Warning);
                return true;
            }

            // Make sure we reload the SOAP template if it has changed
            LoadTemplate();

            // Reset all the Response parameters to reuse
            Dictionary<string, string> oParametersToReuse = new Dictionary<string, string>();
            //Dictionary<String, XmlNode> oResponseParameters = new Dictionary<string, XmlNode>();
            
            StringBuilder oResponses = new StringBuilder();
            StringBuilder oResquests = new StringBuilder();
            // Loop through all the methods we are going to call
            do
            {
                // Get Method and Interface description
                MethodDescription oMethodDescription = null;
                InterfaceDescription oInterfaceDescription = null;
                for (int i = 0; i < oLibraryDesc.Interfaces.Count; i++)
                {
                    InterfaceNode oInterfaceNode = new InterfaceNode(oLibraryDesc.Interfaces[i]);
                    if (oInterfaceNode.Deserialise(oXPathNav))
                        if (1 == oInterfaceNode.MethodNodes.Count)
                        {
                            oMethodDescription = oInterfaceNode.MethodNodes[0].Description;
                            oInterfaceDescription = oInterfaceNode.Description;
                            break;
                        }
                }
                if (null == oMethodDescription)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Could not find a method description for '" + oXPathNav.Name + "' at state '" + StateDesc + "'", Log.LogType.Warning);
                    continue;
                }

                // Import the method body
                XPathNavigator oXPathMethod = oXPathNav.Clone();
                XmlNode oImportedMethodBody = oSOAPRequestXML.ImportNode(((IHasXmlNode)oXPathMethod).GetNode(), true);
                
                // Since we need a node with its original method name, create one and copy children of imported node
                XmlNode oMethodBody = oSOAPRequestXML.CreateElement(oXPathMethod.Prefix, oMethodDescription.MethodName, oXPathMethod.NamespaceURI);
                for (int i = 0; i < oImportedMethodBody.ChildNodes.Count; i++)
                {
                    oMethodBody.AppendChild(oImportedMethodBody.ChildNodes[i].Clone());
                }

                XPathNavigator oMethodXPathNav = oMethodBody.CreateNavigator();
                // Update method parameters with any return parameters from previous requests.  Make sure not to update a parameter
                // if it, or a child node of it is the node we are fuzzing.
                foreach(KeyValuePair<string, string> oParameterToReuse in oParametersToReuse)
                {
                    try
                    {
                        // If the param name is empty, or it's value is empty, then continue
                        if (String.IsNullOrEmpty(oParameterToReuse.Key) || String.IsNullOrEmpty(oParameterToReuse.Value))
                            continue;
                        // Try to find the parameter in the current Xml
                        XPathNavigator oParamXPathNav = GetDescendant(oMethodXPathNav, oParameterToReuse.Key);
                        if (null == oParamXPathNav)
                            continue;
                        // Check if the parameter is the target of fuzzing
                        if (CheckParameterNodeInState(oSOAPRequestXML, oParameterToReuse.Key, oParameterToReuse.Value, StateDesc))
                            continue;
                        // Replace the parameter value
                        oParamXPathNav.InnerXml = oParameterToReuse.Value;
                        //String oInnerXml = oMethodBody.InnerXml;
                        //int iStartIndex = -1;
                        //int iEndIndex = -1;
                        //if (!GetValueIndices(oInnerXml, oParameterToReuse.Key, out iStartIndex, out iEndIndex))
                        //    continue;
                        // Check if the parameter is the target of fuzzing
                        //if (CheckParameterNodeInState(oSOAPRequestXML, oParameterToReuse.Key, oParameterToReuse.Value, StateDesc))
                        //    continue;
                        // Replace the parameter value
                        //oInnerXml = oInnerXml.Substring(0, iStartIndex) + oParameterToReuse.Value + oInnerXml.Substring(iEndIndex, oInnerXml.Length - iEndIndex);
                        // Update the inner XML (if the XML is dodgy this will throw an exception)
                        //oMethodBody.InnerXml = oInnerXml;
                    }
                    catch (Exception e)
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), "There was an error re-using a parameter" + Environment.NewLine + e.Message, Log.LogType.Warning);
                    }
                }

                // Add the method body to the SOAP Body
                if (null != oOldMethodBody)
                    oBody.ReplaceChild(oMethodBody, oOldMethodBody);
                else
                    oBody.AppendChild(oMethodBody);

                // Write out the HTTP body, the SOAP XML
                StringBuilder oOutputXML =  new StringBuilder();
                XmlWriter oWriter = XmlWriter.Create(oOutputXML);
                oSOAPRequestXML.WriteTo(oWriter);
                oWriter.Flush();
                Byte[] oByteOutputXML = Encoding.UTF8.GetBytes(oOutputXML.ToString());
                oWriter.Close();

                // Record the Requests (since they may have been updated)
                oResquests.AppendLine(FormatXML(oOutputXML.ToString()));

                // Get the location for this particular Web Service method
                String sLocation = ((WSDLInterfaceDescription)oInterfaceDescription).WebServiceLocation;
                if (!CheckLocation(sLocation))  // Make sure the location is a valid URL;
                    continue;

                // Set up the HTTP request
                HttpWebRequest oWebRequest = (HttpWebRequest)WebRequest.Create(sLocation);
                oWebRequest.Method = "POST";
                //oWebRequest.SendChunked = false;
                //oWebRequest.Expect = "";
                //oWebRequest.Proxy = GlobalProxySelection.Select;

                // Set the content length (which must be set before writing to the request stream
                oWebRequest.ContentLength = oByteOutputXML.Length;
                // Set the Content-Type
                if (oLibraryDesc.Protocol == WSDLInputProtocol.Soap)
                {
                    // Set the SoapAction header
                    String SoapAction = ((WSDLMethodDescription)oMethodDescription).SoapAction;
                    if (!String.IsNullOrEmpty(SoapAction))
                        oWebRequest.Headers.Add("SoapAction: " + SoapAction);
                    else
                        oWebRequest.Headers.Add("SoapAction: ");

                    oWebRequest.ContentType = "text/xml; charset=utf-8";
                }
                else
                {
                    oWebRequest.ContentType = "application/soap+xml; charset=utf-8";
                }

                Stream oHTTPOutput = null;
                try
                {
                    oHTTPOutput = oWebRequest.GetRequestStream();

                    // Write the request
                    oHTTPOutput.Write(oByteOutputXML, 0, oByteOutputXML.Length);
                    oHTTPOutput.Flush();
                }
                catch (WebException se)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), se.Message + (!String.IsNullOrEmpty(se.InnerException.Message)?(" (" + se.InnerException.Message + ")"):""), Log.LogType.Error);
                }

                try
                {
                    // Send the request
                    HttpWebResponse oWebResponse = (HttpWebResponse)oWebRequest.GetResponse();

                    if (oWebResponse.StatusCode != HttpStatusCode.OK)
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), StateDesc + " has HTTP Status Code: " + oWebResponse.StatusCode.ToString(), Log.LogType.Info);
                    }
                    
                    StreamReader oStreamReader = new StreamReader(oWebResponse.GetResponseStream());
                    String strResponse = oStreamReader.ReadToEnd();
                    oStreamReader.Close();

                    // Record the parameters of the response
                    RecordParameters(strResponse, oParametersToReuse);

                    // Check if this response is unique
                    byte[] byteResponse = Encoding.UTF8.GetBytes(strResponse);
                    if (OutputStats.AddResponse(byteResponse, StateDesc + " (" + oMethodDescription.MethodName + ")"))
                        bContainsUniqueResponse = true;

                    // Concat all responses together for when we write unique responses to file
                    oResponses.AppendLine(FormatXML(strResponse));

                }       
                catch (WebException we)
                {
                    //Log.Write(MethodBase.GetCurrentMethod(), "WebException: " + we.Message, Log.LogType.Warning);
                    oResponses.AppendLine("WebException: " + we.Message);
                    if (null != we.Response)
                    {
                        Stream oRespStream = we.Response.GetResponseStream();
                        if (null != oRespStream)
                        {
                            if (oRespStream.CanSeek)
                                oRespStream.Seek(0, SeekOrigin.Begin);
                            StreamReader oStreamReader = new StreamReader(oRespStream);
                            String strResponse = oStreamReader.ReadToEnd();
                            oStreamReader.Close();
                            // Check if this response is unique
                            byte[] byteResponse = Encoding.UTF8.GetBytes(strResponse);
                            if (OutputStats.AddResponse(byteResponse, StateDesc + " (" + oMethodDescription.MethodName + ")"))
                                bContainsUniqueResponse = true;
                            oResponses.AppendLine(FormatXML(strResponse));
                        }
                    }
                }

                // Record the XmlNode we added to Body so we can replace it in the next method call
                oOldMethodBody = oMethodBody;

                oHTTPOutput.Close();
            }
            while (oXPathNav.MoveToNext());

            // Record unique responses
            if(bContainsUniqueResponse)
                CheckResponse(oResquests.ToString(), oResponses.ToString(), StateDesc, oOutputToWebService.UniqueResponses);
                //CheckResponse(FormatXML(XMLMemoryStream), oResponses.ToString(), StateDesc, oOutputToWebService.UniqueResponses);

            return true;
        }

        private bool CheckParameterNodeInState(XmlDocument oXmlDoc, String ParamName, String ParamValue, String StateDesc)
        {
            // Make an XmlNode to search
            XmlNode oXmlNode = (XmlNode)oXmlDoc.CreateElement(ParamName);
            oXmlNode.InnerXml = ParamValue;
            return CheckParameterNodeInState(oXmlNode, StateDesc);
        }

        /// <summary>
        /// Returns true if the parameter node name, or any child nodes names were found in the state description i.e. we are
        /// currently fuzzing that element.  This is not precise, but there should be no false negatives.
        /// </summary>
        private bool CheckParameterNodeInState(XmlNode oNode, String StateDesc)
        {
            if (!(oNode is XmlElement))
                return false;

            XmlElement oElement = oNode as XmlElement;

            if (StateDesc.Contains(oElement.Name))
                return true;

            if (oElement.HasChildNodes)
            {
                for(int i = 0; i < oElement.ChildNodes.Count; i++)
                    if(CheckParameterNodeInState(oElement.ChildNodes[i], StateDesc))
                        return true;
            }
            return false;
        }

        /// <summary>
        /// Record the response nodes of the method response.  We will try to re-use these where possible.
        /// </summary>
        private void RecordParameters(String oResponseString, Dictionary<String, String> oParametersToReuse)
        {
            if (String.IsNullOrEmpty(oResponseString) || (0 == oParametersToReuseList.Count) || (null == oParametersToReuse))
                return;
            XmlDocument oXmlDoc = new XmlDocument();
            try
            {
                oXmlDoc.LoadXml(oResponseString);
            }
            catch
            {
                return;
            }
            XPathNavigator oRootXPath = oXmlDoc.CreateNavigator();
            // Find the Body
            XPathNavigator oMethodResponseBodyXPath = GetDescendant(oRootXPath, "Body");
            if (null == oMethodResponseBodyXPath)
                return;

            for(int i = 0; i < oParametersToReuseList.Count; i++)
            {
                if (String.IsNullOrEmpty(oParametersToReuseList[i]))
                    continue;
                XPathNavigator oParamXPath = GetDescendant(oMethodResponseBodyXPath, oParametersToReuseList[i]);
                if (null == oParamXPath)
                    continue;
                if (oParametersToReuse.ContainsKey(oParametersToReuseList[i]))
                    oParametersToReuse[oParametersToReuseList[i]] = oParamXPath.InnerXml;
                else
                    oParametersToReuse.Add(oParametersToReuseList[i], oParamXPath.InnerXml);    
                //int iStartIndex = -1;
                //int iEndIndex = -1;
                //if (!GetValueIndices(oResponseString, oParametersToReuseList[i], out iStartIndex, out iEndIndex))
                //    continue;
                //if(oParametersToReuse.ContainsKey(oParametersToReuseList[i]))
                //    oParametersToReuse[oParametersToReuseList[i]] = oResponseString.Substring(iStartIndex, iEndIndex - iStartIndex);
                //else
                //    oParametersToReuse.Add(oParametersToReuseList[i], oResponseString.Substring(iStartIndex, iEndIndex - iStartIndex));    
            }
        }

        /// <summary>
        /// Gets an XPathNavigator pointing to a child node with the name DescendantName.  This function starts looking for a
        /// match on the first node of RootNode
        /// </summary>
        /// <param name="RootNode">Where to start, not included in search</param>
        /// <param name="DescendantName">The node name to look for</param>
        /// <returns></returns>
        private XPathNavigator GetDescendant(XPathNavigator RootNode, String DescendantName)
        {
            if (!RootNode.HasChildren)
                return null;

            XPathNavigator oChildNodes = RootNode.Clone();
            if(!oChildNodes.MoveToFirstChild())
                return null;
            
            do
            {
                // Only check elements
                if (oChildNodes.NodeType != XPathNodeType.Element)
                    continue;
                // Check if this is the one
                if (oChildNodes.LocalName.Equals(DescendantName))
                    return oChildNodes;
                // Chech it's children
                XPathNavigator res = GetDescendant(oChildNodes, DescendantName);
                if (null != res)
                    return res;
                // Check the next node
            }
            while (oChildNodes.MoveToNext(XPathNodeType.Element));

            return null;
        }

        /// <summary>
        /// Returns the index of the first character (iStartIndex) and the index of the character after the last character (iEndIndex)
        /// of the XML node with name Param in SearchString
        /// </summary>
        /// <param name="SearchString">The Xml string to search</param>
        /// <param name="Param">The Xml node name to search for</param>
        /// <param name="iStartIndex">The index of the first character of the Xml node value</param>
        /// <param name="iEndIndex">The index 1 past the end of the Xml node value</param>
        /// <returns>true if the node was found, false otherwise</returns>
        //private bool GetValueIndices(String SearchString, String Param, out int iStartIndex, out int iEndIndex)
        //{
        //    iStartIndex = -1;
        //    iEndIndex = -1;
        //    if(String.IsNullOrEmpty(SearchString) || String.IsNullOrEmpty(Param))
        //        return false;

        //    // First look for the Param with no namespace prefix.  Look for '<Param>'
        //    int iLocalStartIndex = SearchString.IndexOf("<" + Param + ">");
        //    if (-1 == iLocalStartIndex)
        //    {
        //        // There might be no namespace prefix and attributes, so look for '<Param '
        //        iLocalStartIndex = SearchString.IndexOf("<" + Param + " ");
        //        if (-1 == iLocalStartIndex)
        //        {
        //            // There might be a prefix with attributes, so look for ':Param '
        //            iLocalStartIndex = SearchString.IndexOf(":" + Param + " ");
        //            if (-1 == iLocalStartIndex)
        //            {
        //                // Lastly look for ':Param>'.  We do this last since it will also match the closing tag!! </pfx:Param>
        //                iLocalStartIndex = SearchString.IndexOf(":" + Param + ">");
        //                if (-1 == iLocalStartIndex)
        //                    return false;
        //            }
        //        }
        //    }
        //    // From the beginning of the string we found, find the last '>'.  This will skip over any attributes.
        //    iLocalStartIndex = SearchString.IndexOf(">", iLocalStartIndex);
        //    if (-1 == iLocalStartIndex)
        //        return false;
        //    // Move the index to the first character of the value
        //    iLocalStartIndex = iLocalStartIndex + 1;

        //    // Look for the end tag, it will be after the start tag and be surrounded by ':' and '>'
        //    int iLocalEndIndex = SearchString.IndexOf(":" + Param + ">", iLocalStartIndex);
        //    if (-1 == iLocalEndIndex)
        //    {
        //        // Maybe there is no namespace prefix?
        //        iLocalEndIndex = SearchString.IndexOf("</" + Param + ">", iLocalStartIndex);
        //        if (-1 == iLocalEndIndex)
        //            return false;
        //    }
        //    // Do a reality checks
        //    if (iLocalStartIndex >= iLocalEndIndex)
        //        return false;

        //    // We need to find the '<' before the end tag
        //    if (!SearchString.Substring(iLocalEndIndex, 1).Equals("<")) // This will be true in the no-prefix scenario
        //    {
        //        iLocalEndIndex = SearchString.LastIndexOf("<", iLocalEndIndex, iLocalEndIndex - iLocalStartIndex);
        //        if (-1 == iLocalEndIndex)
        //            return false;
        //    }

        //    // Do some reality checks
        //    if (iLocalStartIndex >= iLocalEndIndex)
        //        return false;
        //    if ((iLocalStartIndex < Param.Length) || 
        //        (iLocalStartIndex >= SearchString.Length) || 
        //        (iLocalEndIndex >= (SearchString.Length - Param.Length - 1)))
        //        return false;

        //    iStartIndex = iLocalStartIndex;
        //    iEndIndex = iLocalEndIndex;
        //    return true;
        //}

        /// <summary>
        /// Checks that the location is a URL
        /// </summary>
        private bool CheckLocation(String sLocation)
        {
            // Check the location
            Uri oLocationURI = null;
            try
            {
                oLocationURI = new Uri(sLocation);
            }
            catch (Exception e)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Service location '" + sLocation + "' not a valid URL.  Error: " + e.Message, Log.LogType.Warning);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Format a raw stream of XML for presenting to the user
        /// </summary>
        private String FormatXML(Stream oStream)
        {
            if (oStream.CanSeek)
                oStream.Seek(0, SeekOrigin.Begin);
            StreamReader oStreamReader = new StreamReader(oStream);
            String strContents = oStreamReader.ReadToEnd();
            oStreamReader.Close();
            return FormatXML(strContents);
        }

        /// <summary>
        /// Format a raw string of XML for presenting to the user
        /// </summary>
        private String FormatXML(String oResponseStr)
        {
            try
            {
                XmlWriterSettings oXmlSettings = new XmlWriterSettings();
                oXmlSettings.Indent = true;
                oXmlSettings.NewLineHandling = NewLineHandling.None;

                StringWriter oStringWriter = new StringWriter();
                XmlWriter Writer = XmlWriter.Create(oStringWriter, oXmlSettings);
                XmlDocument oXmlDoc = new XmlDocument();
                oXmlDoc.LoadXml(oResponseStr);
                oXmlDoc.WriteContentTo(Writer);
                Writer.Flush();
                return oStringWriter.ToString();
            }
            catch
            {
                return oResponseStr;
            }
        }

        /// <summary>
        /// Determine if this testcase of the web service methods produced a unique response
        /// </summary>
        private void CheckResponse(String oRequestString, String oResponseStrings, String StateDesc, FileStoreWithTolerance UniqueResponses)
        {
            String strResponse = oResponseStrings;
            // Get the response as a byte array
            byte[] Response = Encoding.UTF8.GetBytes(strResponse);

            // Determine if this was a unique response
            //if (OutputStats.AddResponse(Response, StateDesc))
            //{
                // Record the test case
                String StoredTestCase = CreateOutputFilePathString(UniqueResponses.Directory, StateDesc, "xml");
                // Open and output to file
                try
                {
                    using (FileStream fs = new FileStream(StoredTestCase, FileMode.Create, FileAccess.Write))
                    {
                        byte[] RequestBytes = Encoding.UTF8.GetBytes(oRequestString);
                        fs.Write(RequestBytes, 0, RequestBytes.Length);
                    }
                }
                catch (Exception e)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "An error occurred saving the test case '" + StateDesc + "'" +
                            Environment.NewLine + e.Message, Log.LogType.Warning);
                }

                // Record the unique response
                String UniqueRespPathAndFile = Path.ChangeExtension(Path.Combine(Path.GetDirectoryName(StoredTestCase), Path.GetFileNameWithoutExtension(StoredTestCase) + ".Response."), UniqueResponses.FileExtension);

                // Open and output to file
                try
                {
                    using (FileStream fs = new FileStream(UniqueRespPathAndFile, FileMode.Create, FileAccess.Write))
                    {
                        fs.Write(Response, 0, Response.Length);
                    }
                }
                catch (Exception e)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "An error occurred saving the response for test case '" + StateDesc + "'" +
                            Environment.NewLine + e.Message, Log.LogType.Warning);
                }
            //}
        }
    }
}
