using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Reflection;
using System.Diagnostics;
using System.Threading;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using Fuzzware.Common;
using Fuzzware.Evaluate;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Convert2XML;
using Fuzzware.Evaluate.Statistics;

using Microsoft.Win32.SafeHandles;  //delete

namespace Fuzzware.Evaluate
{
    public class OutputToExeHandler : OutputHandler
    {
        OutputToExe oOutputToExe;
        ProcessProxy OutputExe;

        //StringBuilder StdOutOutput;
        //StringBuilder StdErrOutput;

        //static bool bHasDefAppTermBehviourBeenSet = false;
        //static bool bAppTermSelfByDefault = false;

        [DllImport("user32.dll")]
        static extern IntPtr GetTopWindow(IntPtr hWnd);
        [DllImport("user32.dll")]
        static extern IntPtr GetForegroundWindow();
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern int GetWindowTextLength(IntPtr hWnd);
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern int GetWindowText(IntPtr hWnd, [Out] StringBuilder lpString, int nMaxCount);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool SetForegroundWindow(IntPtr hWnd);
        [DllImport("user32")]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool EnumChildWindows(IntPtr window, EnumWindowProc callback, IntPtr i);
        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);
        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        [DllImport("user32.dll", SetLastError = true)]
        static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);

        public override void Initialise(object Settings, InputHandler oInputHandler)
        {
            if (!(Settings is OutputToExe))
                Log.Write(MethodInfo.GetCurrentMethod(), "Expected Settings object of type 'outputToExe', got '" + Settings.GetType().ToString() + "'", Log.LogType.Error);

            oOutputToExe = Settings as OutputToExe;

            if (String.IsNullOrEmpty(oOutputToExe.InputFromFile.Directory))
                oOutputToExe.InputFromFile.Directory = Environment.CurrentDirectory;
            if (String.IsNullOrEmpty(oOutputToExe.UniqueOutputs.Directory))
                oOutputToExe.UniqueOutputs.Directory = Environment.CurrentDirectory;

            //bHasDefAppTermBehviourBeenSet = false;
            //bAppTermSelfByDefault = false;

            // Insert the working directory into the command line.  This is constant, so only needs to be done once.
            String WorkingDirToken = oOutputToExe.CommandLineParameters.WorkingDirToken;

            Regex cmdline = new Regex(Regex.Escape(WorkingDirToken));
            String FmtCmdLine = "";
            if (!String.IsNullOrEmpty(oOutputToExe.CommandLineParameters.Value))
            {
                FmtCmdLine = cmdline.Replace(oOutputToExe.CommandLineParameters.Value, Environment.CurrentDirectory);
                oOutputToExe.CommandLineParameters.Value = FmtCmdLine;
            }

            // Create proxy for running the target process
            OutputExe = ProcessProxy.CreateProcessProxy(oOutputToExe);
        }

        #region to delete
        //public bool Output1(System.IO.MemoryStream XMLMemoryStream, string StateDesc)
        //{
        //    if (null == XMLMemoryStream)
        //        Log.Write(MethodBase.GetCurrentMethod(), "The input MemoryStream was null", Log.LogType.Error);
        //    if (null == StateDesc)
        //        Log.Write(MethodBase.GetCurrentMethod(), "The input State was null", Log.LogType.Error);

        //    // Check Exe exists
        //    if (!File.Exists(oOutputToExe.ExePathAndName.Value))
        //        Log.Write(MethodBase.GetCurrentMethod(), "The specified executable '" + oOutputToExe.ExePathAndName + "' could not be found", Log.LogType.Error);

        //    FileStore inputFile = oOutputToExe.InputFromFile;

        //    // Write the XML out to file
        //    // At this stage it is important that each testcase has the same filename, this is because we check for the uniqueness of the
        //    // exe's response, and often the response will have the filename in it.  If each test case has a different filename, then
        //    // the exe's response will be different each time, and we would have to apply some processing to determine if it is
        //    // unique bar the input filename.
        //    // Updated - We now allow the user to specify whether ot not the same filename will be used each time
        //    String Testcasefilename = null;
        //    if (oOutputToExe.CommandLineParameters.SingleTestcaseFilename)
        //        Testcasefilename = "testcase";
        //    else
        //        Testcasefilename = StateDesc;

        //    String InputPathAndFile = CreateOutputFilePathString(inputFile.Directory, Testcasefilename, inputFile.FileExtension);

        //    // Open and output to file
        //    try
        //    {
        //        using (FileStream fs = new FileStream(InputPathAndFile, FileMode.Create, FileAccess.Write))
        //        {
        //            XMLMemoryStream.WriteTo(fs);
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        Log.Write(MethodBase.GetCurrentMethod(), "An error occurred writing the testcase for state '" + StateDesc + "'.  Skipping." +
        //            Environment.NewLine + e.Message, Log.LogType.Warning);
        //        return true;
        //    }

        //    // Insert the output file into the command line parameters
        //    String FilenameToken = oOutputToExe.CommandLineParameters.FilenameToken;

        //    Regex cmdline = new Regex(Regex.Escape(FilenameToken));

        //    String FmtCmdLine = "";
        //    if (!String.IsNullOrEmpty(oOutputToExe.CommandLineParameters.Value))
        //    {
        //        if (!cmdline.IsMatch(oOutputToExe.CommandLineParameters.Value))
        //            Log.Write(MethodBase.GetCurrentMethod(), "The token used to identify where the output file name and path is placed in the command line is missing.", Log.LogType.Error);

        //        FmtCmdLine = cmdline.Replace(oOutputToExe.CommandLineParameters.Value, InputPathAndFile);
        //    }

        //    // Run Exe with command line parameters
        //    Process OutputExe = new Process();

        //    OutputExe.StartInfo.FileName = oOutputToExe.ExePathAndName.Value;
        //    OutputExe.StartInfo.Arguments = FmtCmdLine;
        //    OutputExe.StartInfo.UseShellExecute = false;
        //    OutputExe.StartInfo.RedirectStandardOutput = true;
        //    OutputExe.StartInfo.RedirectStandardError = true;
        //    OutputExe.OutputDataReceived += new DataReceivedEventHandler(StdOutOutputHandler);
        //    OutputExe.ErrorDataReceived += new DataReceivedEventHandler(StdErrOutputHandler);
        //    StdOutOutput = new StringBuilder();
        //    StdErrOutput = new StringBuilder();
        //    int ProcessDelay = (int)oOutputToExe.ProcessDelay;
            
        //    int OpenDelay = 100;
        //    int CloseDelay = 100;
        //    if (null != oOutputToExe.ExeOpenActions)
        //        OpenDelay = (int)oOutputToExe.ExeOpenActions.OpenDelayMilliSecs;
        //    else  // Use the default values
        //        OpenDelay = (int)(new OutputToExeExeOpenActions()).OpenDelayMilliSecs;
        //    if (null != oOutputToExe.ExeCloseActions)
        //        CloseDelay = (int)oOutputToExe.ExeCloseActions.CloseDelayMilliSecs;
        //    else  // Use the default values
        //        CloseDelay = (int)(new OutputToExeExeCloseActions()).CloseDelayMilliSecs;
            
        //    bool AppWasKilled = false;

        //    // Execute!!
        //    OutputExe.Start();

        //    //Now is an excellent time for a GC
        //    GC.Collect(GC.MaxGeneration);

        //    Thread.Sleep(OpenDelay);

        //    // Process any window actions that occur at startup
        //    if ((null != oOutputToExe.ExeOpenActions) && (null != oOutputToExe.ExeOpenActions.OpenWindowAction))
        //        ProcessWindowActions(OutputExe.MainWindowHandle, oOutputToExe.ExeOpenActions.OpenWindowAction);

        //    // Read the standard output and error of the Exe.
        //    OutputExe.BeginOutputReadLine();
        //    OutputExe.BeginErrorReadLine();

        //    OutputExe.WaitForExit(ProcessDelay);

        //    if (!OutputExe.HasExited)
        //    {
        //        // If the default behaviour of the app is to terminate itself and it doesn't, this is not interesting unless we have to kill the
        //        // app, which will be detected (this reasoning is why this code block does not refer to bAppTermSelfByDefault)
        //        try
        //        {
        //            //OutputExe.WaitForInputIdle(3000);
        //            OutputExe.Refresh();
        //            OutputExe.CloseMainWindow();
        //            OutputExe.Refresh();
        //            Thread.Sleep(CloseDelay);
        //            if (!OutputExe.HasExited)
        //            {
        //                if ((null != oOutputToExe.ExeCloseActions) && (null != oOutputToExe.ExeCloseActions.CloseWindowAction))
        //                    ProcessWindowActions(OutputExe.MainWindowHandle, oOutputToExe.ExeCloseActions.CloseWindowAction);

        //                try
        //                {
        //                    OutputExe.Refresh();
        //                    OutputExe.CloseMainWindow();
        //                    OutputExe.Refresh();
        //                    OutputExe.WaitForExit(CloseDelay);
        //                }
        //                catch { }
        //            }
        //        }
        //        catch (Exception e)
        //        {
        //            Log.Write(MethodBase.GetCurrentMethod(), e.Message, Log.LogType.Warning);
        //        }

        //        if (!OutputExe.HasExited)
        //        {
        //            AppWasKilled = true;
        //            try
        //            {
        //                OutputExe.Kill();
        //            }
        //            catch { }
        //            Thread.Sleep(1000);
        //        }
        //    }
        //    else
        //    {
        //        // If the default behaviour has not been set, then set it (this should happen only during the testcase)
        //        if (!bHasDefAppTermBehviourBeenSet)
        //        {
        //            bAppTermSelfByDefault = true;
        //            bHasDefAppTermBehviourBeenSet = true;
        //            Log.Write(MethodBase.GetCurrentMethod(), "Schemer detected this application terminates itself (if this is not the case " +
        //                "then the application needs to be given enough time to process the default testcase and terminate)", Log.LogType.LogOnlyInfo);
        //        }
        //        else
        //        {   // If the app does not normally terminate itself, but it has in this case, this is interesting.
        //            if (!bAppTermSelfByDefault)
        //                AppWasKilled = true;
        //        }
        //    }

        //    // The process has finished running, so Close it to free up its resources
        //    OutputExe.Close();

        //    AppWasKilled = AppWasKilled | CheckForCrashedProcess(StateDesc);

        //    string output = StdOutOutput.ToString() + " " + StdErrOutput.ToString();

        //    // Check if the exe input file is going to be the same as our interesting stored test case, because if they are
        //    // at the same location, we don't need to copy and we don't need to delete.
        //    bool bInputEqualsStoredTestcase = false;
        //    // Determine if this was a unique response
        //    if (OutputStats.AddResponse(output, StateDesc) || AppWasKilled)
        //    {
        //        // Record the test case
        //        String StoredTestCase = CreateOutputFilePathString(oOutputToExe.UniqueOutputs.Directory, StateDesc, inputFile.FileExtension);
        //        try
        //        {
        //            if (InputPathAndFile.Equals(StoredTestCase, StringComparison.CurrentCultureIgnoreCase))
        //                bInputEqualsStoredTestcase = true;
        //            else
        //                File.Copy(InputPathAndFile, StoredTestCase, true);
        //        }
        //        catch (Exception e)
        //        {
        //            Log.Write(MethodBase.GetCurrentMethod(), "An error occurred copying the input test case '" + StateDesc + "' to the output directory.  " +
        //                    "This testcase was interesting." + Environment.NewLine + e.Message, Log.LogType.LogOnlyInfo);
        //        }

        //        // If the App was killed then ignore response
        //        if (!AppWasKilled)
        //        {
        //            // Change the default file extension for unique response files
        //            if (oOutputToExe.UniqueOutputs.FileExtension == "xml")
        //                oOutputToExe.UniqueOutputs.FileExtension = "txt";

        //            // Record the unique response
        //            String FileExt = oOutputToExe.UniqueOutputs.FileExtension;
        //            if (!FileExt.StartsWith("."))
        //                FileExt = "." + FileExt;

        //            String UniqueRespPathAndFile = StoredTestCase + FileExt;

        //            // Open and output to file
        //            try
        //            {
        //                using (FileStream fs = new FileStream(UniqueRespPathAndFile, FileMode.Create, FileAccess.Write, FileShare.ReadWrite))
        //                {
        //                    StreamWriter sw = new StreamWriter(fs);
        //                    sw.Write(output);
        //                    sw.Flush();
        //                }
        //            }
        //            catch (Exception e)
        //            {
        //                Log.Write(MethodBase.GetCurrentMethod(), "An error occurred saving the output for test case '" + StateDesc + "'" +
        //                    Environment.NewLine + e.Message, Log.LogType.Warning);
        //            }
        //        }
        //        else
        //        {
        //            OutputStats.AddTestcaseRequiredKillingApp(StateDesc);
        //        }
        //    }

        //    try
        //    {
        //        if (!bInputEqualsStoredTestcase)
        //        {
        //            // Delete input file
        //            File.Delete(InputPathAndFile);
        //        }
        //    }
        //    catch (Exception e)
        //    {
        //        Log.Write(MethodBase.GetCurrentMethod(), "Unable to delete testcase for state '" + StateDesc + "'" +
        //            Environment.NewLine + e.Message, Log.LogType.LogOnlyInfo);
        //    }

        //    return true;
        //}

        //private void StdOutOutputHandler(object sendingProcess, DataReceivedEventArgs outLine)
        //{
        //    // Collect the sort command output.
        //    if (!String.IsNullOrEmpty(outLine.Data))
        //    {
        //        StdOutOutput.Append(outLine.Data);
        //    }
        //}

        //private void StdErrOutputHandler(object sendingProcess, DataReceivedEventArgs outLine)
        //{
        //    // Collect the sort command output.
        //    if (!String.IsNullOrEmpty(outLine.Data))
        //    {
        //        StdErrOutput.Append(outLine.Data);
        //    }
        //}
        #endregion

        #region WriteToFile with ADS

        //[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        //private static extern SafeFileHandle CreateFile(string lpFileName,
        //    FileAccess dwDesiredAccess, FileShare dwShareMode,
        //    IntPtr lpSecurityAttributes, FileMode dwCreationDisposition,
        //    int dwFlagsAndAttributes, IntPtr hTemplateFile);

        ///// <summary>
        ///// Create a file stream, we have to use CreateStream directly as System.IO does not let us create file streams
        ///// </summary>
        //private static FileStream CreateFileStream(string path, FileAccess access, FileMode mode, FileShare share)
        //{
        //    if (mode == FileMode.Append)
        //        mode = FileMode.OpenOrCreate;

        //    SafeFileHandle handle = CreateFile(path, FileAccess.Write, share, IntPtr.Zero, mode, 0, IntPtr.Zero);
        //    if (handle.IsInvalid)
        //    {
        //        Log.Write(MethodBase.GetCurrentMethod(), "Could not create file stream '" + path + "'", Log.LogType.Warning);
        //        return null;
        //    }
        //    return new FileStream(handle, access);
        //}

        ///// <summary>
        ///// We write the file but then add an Alternate Data Stream to indicate the file came from the Intranet Zone, this
        ///// means IE will play it without warning (for typical configurations).
        ///// </summary>
        //protected override bool WriteToFile(MemoryStream XMLMemoryStream, string InputPathAndFile, string StateDesc)
        //{
        //    if (!base.WriteToFile(XMLMemoryStream, InputPathAndFile, StateDesc))
        //        return false;

        //    // Add Zone.Identifier Alternate Data Stream to file
        //    String ZoneIdADSName = Path.GetFullPath(InputPathAndFile) + ":Zone.Identifier";
        //    FileStream ADSStream = CreateFileStream(ZoneIdADSName, FileAccess.Write, FileMode.Create, FileShare.None);
        //    if (null == ADSStream)
        //        return false;
        //    // Write ADS text
        //    // [ZoneTransfer]
        //    // ZoneId=1
        //    String ADSText = "[ZoneTransfer]" + Environment.NewLine + "ZoneId=1";
        //    byte[] ADSBytes = Encoding.Unicode.GetBytes(ADSText);
        //    ADSStream.Write(ADSBytes, 0, ADSBytes.Length);
        //    ADSStream.Flush();
        //    ADSStream.Close();
        //    return true;
        //}

        #endregion

        public override bool Output(System.IO.MemoryStream XMLMemoryStream, string StateDesc)
        {
            if (null == XMLMemoryStream)
                Log.Write(MethodBase.GetCurrentMethod(), "The input MemoryStream was null", Log.LogType.Error);
            if (null == StateDesc)
                Log.Write(MethodBase.GetCurrentMethod(), "The input State was null", Log.LogType.Error);

            // Check Exe exists
            if (!File.Exists(oOutputToExe.ExePathAndName.Value))
                Log.Write(MethodBase.GetCurrentMethod(), "The specified executable '" + oOutputToExe.ExePathAndName.Value + "' could not be found", Log.LogType.Error);

            FileStore inputFile = oOutputToExe.InputFromFile;

            // Write the XML out to file
            // At this stage it is important that each testcase has the same filename, this is because we check for the uniqueness of the
            // exe's response, and often the response will have the filename in it.  If each test case has a different filename, then
            // the exe's response will be different each time, and we would have to apply some processing to determine if it is
            // unique bar the input filename.
            // Updated - We now allow the user to specify whether ot not the same filename will be used each time
            String Testcasefilename = null;
            if (oOutputToExe.CommandLineParameters.SingleTestcaseFilename)
                Testcasefilename = "testcase";
            else
                Testcasefilename = StateDesc;

            String InputPathAndFile = CreateOutputFilePathString(inputFile.Directory, Testcasefilename, inputFile.FileExtension);

            // Open and output to file
            if (!WriteToFile(XMLMemoryStream, InputPathAndFile, StateDesc))
                return true;

            // Insert the output file into the command line parameters
            String FilenameToken = oOutputToExe.CommandLineParameters.FilenameToken;

            Regex cmdline = new Regex(Regex.Escape(FilenameToken));

            String FmtCmdLine = "";
            if (!String.IsNullOrEmpty(oOutputToExe.CommandLineParameters.Value))
            {
                if (!cmdline.IsMatch(oOutputToExe.CommandLineParameters.Value))
                    Log.Write(MethodBase.GetCurrentMethod(), "The token used to identify where the output file name and path is placed in the command line is missing.", Log.LogType.Error);

                FmtCmdLine = cmdline.Replace(oOutputToExe.CommandLineParameters.Value, InputPathAndFile);
            }

            // Execute!!
            OutputExe.Run(FmtCmdLine, StateDesc);

            bool AppWasKilled = OutputExe.AppWasKilled();

            string output = OutputExe.ProcessOutput();

            // Check if the exe input file is going to be the same as our interesting stored test case, because if they are
            // at the same location, we don't need to copy and we don't need to delete.
            bool bInputEqualsStoredTestcase = false;
            // Determine if this was a unique response
            if (OutputStats.AddResponse(output, StateDesc) || AppWasKilled)
            {
                // Record the test case
                String StoredTestCase = CreateOutputFilePathString(oOutputToExe.UniqueOutputs.Directory, StateDesc, inputFile.FileExtension);
                try
                {
                    if (InputPathAndFile.Equals(StoredTestCase, StringComparison.CurrentCultureIgnoreCase))
                        bInputEqualsStoredTestcase = true;
                    else
                        File.Copy(InputPathAndFile, StoredTestCase, true);
                }
                catch (Exception e)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "An error occurred copying the input test case '" + StateDesc + "' to the output directory.  " +
                            "This testcase was interesting." + Environment.NewLine + e.Message, Log.LogType.LogOnlyInfo);
                }

                // If the App wasn't killed then record response
                if (!AppWasKilled)
                {
                    // Change the default file extension for unique response files
                    if (oOutputToExe.UniqueOutputs.FileExtension == "xml")
                        oOutputToExe.UniqueOutputs.FileExtension = "txt";

                    // Record the unique response
                    String FileExt = oOutputToExe.UniqueOutputs.FileExtension;
                    if (!FileExt.StartsWith("."))
                        FileExt = "." + FileExt;

                    String UniqueRespPathAndFile = StoredTestCase + FileExt;

                    // Open and output to file
                    try
                    {
                        using (FileStream fs = new FileStream(UniqueRespPathAndFile, FileMode.Create, FileAccess.Write, FileShare.ReadWrite))
                        {
                            StreamWriter sw = new StreamWriter(fs);
                            sw.Write(output);
                            sw.Flush();
                        }
                    }
                    catch (Exception e)
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), "An error occurred saving the output for test case '" + StateDesc + "'" +
                            Environment.NewLine + e.Message, Log.LogType.Warning);
                    }
                }
                else
                {
                    // If the App was killed then ignore response
                    OutputStats.AddTestcaseRequiredKillingApp(StateDesc);
                }
            }

            try
            {
                if (!bInputEqualsStoredTestcase)
                {
                    // Delete input file
                    File.Delete(InputPathAndFile);
                }
            }
            catch (Exception e)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Unable to delete testcase for state '" + StateDesc + "'" +
                    Environment.NewLine + e.Message, Log.LogType.LogOnlyInfo);
            }

            return true;
        }

        private string GetWindowTitleText(IntPtr hWnd)
        {
            // Allocate correct string length first
            int length = GetWindowTextLength(hWnd);
            StringBuilder sb = new StringBuilder(length + 1);
            GetWindowText(hWnd, sb, sb.Capacity);
            return sb.ToString();
        }

        /// <summary>
        /// Returns a list of child windows
        /// </summary>
        /// <param name="parent">Parent of the windows to return</param>
        /// <returns>List of child windows</returns>
        private List<IntPtr> GetChildWindows(IntPtr parent)
        {
            List<IntPtr> result = new List<IntPtr>();
            GCHandle listHandle = GCHandle.Alloc(result);
            try
            {
                EnumWindowProc childProc = new EnumWindowProc(EnumWindow);
                EnumChildWindows(parent, childProc, GCHandle.ToIntPtr(listHandle));
            }
            finally
            {
                if (listHandle.IsAllocated)
                    listHandle.Free();
            }
            return result;
        }

        /// <summary>
        /// Callback method to be used when enumerating windows.
        /// </summary>
        /// <param name="handle">Handle of the next window</param>
        /// <param name="pointer">Pointer to a GCHandle that holds a reference to the list to fill</param>
        /// <returns>True to continue the enumeration, false to bail</returns>
        private bool EnumWindow(IntPtr handle, IntPtr pointer)
        {
            GCHandle gch = GCHandle.FromIntPtr(pointer);
            List<IntPtr> list = gch.Target as List<IntPtr>;
            if (list == null)
            {
                throw new InvalidCastException("GCHandle Target could not be cast as List<IntPtr>");
            }
            list.Add(handle);
            //  You can modify this to check to see if you want to cancel the operation, then return a null here
            return true;
        }

        /// <summary>
        /// Delegate for the EnumChildWindows method
        /// </summary>
        /// <param name="hWnd">Window handle</param>
        /// <param name="parameter">Caller-defined variable; we use it for a pointer to our list</param>
        /// <returns>True to continue enumerating, false to bail.</returns>
        private delegate bool EnumWindowProc(IntPtr hWnd, IntPtr parameter);

        /// <summary>
        /// Send window actions to a window of a certain name, with the following conditions
        ///  - the window must have the same process id as the app window (on crashes the the crash window has the same name as the 
        ///  app window and that leads to confusion, so we differentiate by process id)
        ///  - if the window to receive the action is the main app window, send keys in another thread (if the main app is hung and we
        ///  send it keys then this process hangs waiting for the keys to be processed)
        /// </summary>
        private void ProcessWindowActions(IntPtr hParentWnd, WindowAction[] WindowActions)
        {
            if (null == WindowActions)
                return;

            uint TargetProcessId = 0;
            GetWindowThreadProcessId(hParentWnd, out TargetProcessId);

            for (int i = 0; i < WindowActions.Length; i++)
            {
                IntPtr hWnd = FindWindow(null, WindowActions[i].WindowTitle);
                if (hWnd != IntPtr.Zero)
                {
                    uint WindowProcessId = 0;
                    GetWindowThreadProcessId(hWnd, out WindowProcessId);
                    if(WindowProcessId == TargetProcessId)
                    {
                        //Console.WriteLine("Found: " + WindowActions[i].WindowTitle);
                        if (null != WindowActions[i].KeyboardStrokes)
                        {
                            if (SetForegroundWindow(hWnd))
                            {
                                for (int j = 0; j < WindowActions[i].KeyboardStrokes.Length; j++)
                                {
                                    //if (hParentWnd != hWnd)
                                    //    System.Windows.Forms.SendKeys.SendWait(WindowActions[i].KeyboardStrokes[j]);
                                    //else
                                    //{
                                        // If the apps main window has the same name as the popup window and FindWindow returns the
                                        // main window, then it will send it messages instead of the pop-up.  Also, if the main app 
                                        // has hung, then SendWait will wait forever (I think) and Schemer will cause a CPU DoS. The
                                        // solution: if sending keys to the main window, do it in a seperate thread
                                        ThreadedSendKey(WindowActions[i].KeyboardStrokes[j]);
                                    //}
                                }
                            }
                            else
                                Log.Write(MethodBase.GetCurrentMethod(), "Could not set foreground window", Log.LogType.Warning);
                        }
                    }
                    break;
                }
            }

        }

        private void ThreadedSendKey(String Key)
        {
            ParameterizedThreadStart pts = new ParameterizedThreadStart(ThreadedSendKeyMethod);
            Thread SendKeyThread = new Thread(pts);
            SendKeyThread.Start(Key);
            //System.Windows.Forms.SendKeys.Send(WindowActions[i].KeyboardStrokes[j]);
            Thread.Sleep(500);
            if (SendKeyThread.IsAlive)
            {
                Thread.Sleep(500);
                SendKeyThread.Abort();
            }
        }

        private void ThreadedSendKeyMethod(object o)
        {
            try
            {
                System.Windows.Forms.SendKeys.SendWait(o as string);
            }
            catch { }
        }

        private bool CheckForCrashedProcess(String StateDesc)
        {
            // On XP we look for ...
            if (CheckForWatson(StateDesc))
                return true;

            // On Vista we look for ...
            if (CheckForWER(StateDesc))
                return true;

            return false;
        }

        /// <summary>
        /// Checks if dwwin.exe is running, if so, assumes a crash.
        /// </summary>
        /// <returns>True if a crash is detected, false otherwise</returns>
        private bool CheckForWatson(String StateDesc)
        {
            Process[] oProcesses = Process.GetProcessesByName("dwwin");
            if (0 == oProcesses.Length)
                return false;

            // Set the dwwin to be the forground window, and send it an 'Enter' to close it
            for (int i = 0; i < oProcesses.Length; i++)
            {
                try
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Closing Dr Watson window for state '" + StateDesc + "'", Log.LogType.Info);

                    SetForegroundWindow(oProcesses[i].MainWindowHandle);
                    ThreadedSendKey("{Enter}");

                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].CloseMainWindow();
                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].Kill();
                    oProcesses[i].Close();
                }
                catch { }
            }
            return true;
        }

        /// <summary>
        /// Checks if WerFault.exe is running, if so, assumes a crash.
        /// </summary>
        /// <returns>True if a crash is detected, false otherwise</returns>
        private bool CheckForWER(String StateDesc)
        {
            Process[] oProcesses = Process.GetProcessesByName("WerFault");
            if (0 == oProcesses.Length)
                return false;

            // Set the dwwin to be the forground window, and send it an 'Enter' to close it
            for (int i = 0; i < oProcesses.Length; i++)
            {
                try
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Closing WER window for state '" + StateDesc + "'", Log.LogType.Info);

                    IntPtr hWindowHandle = FindWindow(null, oProcesses[i].MainWindowTitle);
                    if (null != hWindowHandle)
                    {
                        SetForegroundWindow(hWindowHandle);
                        ThreadedSendKey("{Enter}");
                    }
                    else
                    {
                        SetForegroundWindow(oProcesses[i].MainWindowHandle);
                        ThreadedSendKey("{Enter}");
                    }

                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].CloseMainWindow();
                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].Kill();
                    oProcesses[i].Close();
                }
                catch { }
            }
            return true;
        }
    }
}
