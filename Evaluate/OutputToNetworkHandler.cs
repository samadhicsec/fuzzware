using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Reflection;
using System.Xml;
using System.Xml.XPath;
using System.Net;
using System.Net.Sockets;
using System.Net.Security;
using System.Security.Authentication;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Evaluate.Statistics;
using AutoGenerated = Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.ConvertFromXML;
using Fuzzware.Convert2XML;

namespace Fuzzware.Evaluate
{
    public class OutputToNetworkHandler : OutputHandler
    {
        OutputToNetwork oOutputToNetwork;

        IPEndPoint EndPoint;
        TcpClient client;
        Stream NetStream;

        public override void Initialise(object Settings, InputHandler oInputHandler)
        {
            if (!(Settings is OutputToNetwork))
                Log.Write(MethodInfo.GetCurrentMethod(), "Expected Settings object of type 'outputToNetwork', got '" + Settings.GetType().ToString() + "'", Log.LogType.Error);

            oOutputToNetwork = Settings as OutputToNetwork;

            if (String.IsNullOrEmpty(oOutputToNetwork.UniqueResponses.Directory))
                oOutputToNetwork.UniqueResponses.Directory = Environment.CurrentDirectory;
        }

        //public OutputToNetwork OutputToNetwork
        //{
        //    get
        //    {
        //        return oOutputToNetwork;
        //    }
        //}

        public override bool Output(System.IO.MemoryStream XMLMemoryStream, string StateDesc)
        {
            if (null == XMLMemoryStream)
                Log.Write(MethodBase.GetCurrentMethod(), "The input MemoryStream was null", Log.LogType.Error);
            if (null == StateDesc)
                Log.Write(MethodBase.GetCurrentMethod(), "The input State was null", Log.LogType.Error);

            // Record the endpoint to avoid a potential DNS query with each output
            if (null == EndPoint)
            {
                EndPoint = CreateEndPoint(oOutputToNetwork);
            }

            // Connect to the server
            if (null == client)
                client = new TcpClient();
            if (!client.Connected)
                try
                {
                    client.Connect(EndPoint);
                }
                catch (SocketException se)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), se.Message, Log.LogType.Error);
                }
                catch (Exception e)
                {
                    Log.Write(e);
                }

            if (!client.Connected)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Unable to connect to '" + EndPoint.Address.ToString() + "'", Log.LogType.Info);
                return true;
            }

            // Get the stream to write the network message to
            if (NetStream == null)
                NetStream = GetOutputStream(client, oOutputToNetwork);

            bool bErrorWriting = false;
            try
            {
                // Write out our message
                XMLMemoryStream.WriteTo(NetStream);
                NetStream.Flush();
            }
            catch
            {
                bErrorWriting = true;
            }

            //Now is an excellent time for a GC
            GC.Collect(GC.MaxGeneration);

            // Read in the response
            byte[] Response = null;
            if(!bErrorWriting)
                Response = ReadResponse(client, NetStream);

            // Determine if this was a unique response
            if (bErrorWriting || OutputStats.AddResponse(Response, StateDesc))
            {
                // Record the test case
                String StoredTestCase = CreateOutputFilePathString(oOutputToNetwork.UniqueResponses.Directory, StateDesc, "txt");
                // Open and output to file
                try
                {
                    using (FileStream fs = new FileStream(StoredTestCase, FileMode.Create, FileAccess.Write))
                    {
                        XMLMemoryStream.WriteTo(fs);
                    }
                }
                catch (Exception e)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "An error occurred saving the test case '" + StateDesc + "'" +
                            Environment.NewLine + e.Message, Log.LogType.Warning);
                }

                // Change the default file extension for unique response files
                if (oOutputToNetwork.UniqueResponses.FileExtension == "xml")
                    oOutputToNetwork.UniqueResponses.FileExtension = "txt";

                // Record the unique response
                String FileExt = oOutputToNetwork.UniqueResponses.FileExtension;
                if (!FileExt.StartsWith("."))
                    FileExt = "." + FileExt;

                String UniqueRespPathAndFile = StoredTestCase + FileExt;

                // Open and output to file
                if (!bErrorWriting)
                {
                    try
                    {
                        using (FileStream fs = new FileStream(UniqueRespPathAndFile, FileMode.Create, FileAccess.Write))
                        {
                            fs.Write(Response, 0, Response.Length);
                        }
                    }
                    catch (Exception e)
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), "An error occurred saving the response for test case '" + StateDesc + "'" +
                                Environment.NewLine + e.Message, Log.LogType.Warning);
                    }
                }
            }

            // Close the stream
            NetStream.Close();

            // Close the client
            client.Close();
            client = null;

            NetStream = null;
            return true;
        }

        private Stream GetOutputStream(TcpClient client, OutputToNetwork config)
        {
            // If output to IP, or URI with SSL="false"
            if ((config.Item is String) || ((config.Item is OutputToNetworkURI) && !((config.Item as OutputToNetworkURI).UseSSL)))
            {
                NetworkStream nstream = client.GetStream();
                nstream.ReadTimeout = 10000;
                return nstream;
            }
            else
            {
                // Use SSL
                OutputToNetworkURI configURI = config.Item as OutputToNetworkURI;
                SslStream sslStream = new SslStream(client.GetStream(), false, CertificateValidationCallback);
                sslStream.ReadTimeout = 10000;
                try
                {
                    sslStream.AuthenticateAsClient(configURI.Value);
                }
                catch (AuthenticationException e)
                {
                    sslStream.Close();
                    Log.Write(MethodBase.GetCurrentMethod(), "Failed to authenticate server" + Environment.NewLine + e.Message, Log.LogType.Error);
                }
                return sslStream;
            }
        }

        private bool CertificateValidationCallback(
            object sender, 
            System.Security.Cryptography.X509Certificates.X509Certificate certificate, 
            System.Security.Cryptography.X509Certificates.X509Chain chain, 
            SslPolicyErrors sslPolicyErrors)
        {
            return true;
        }

        private IPEndPoint CreateEndPoint(OutputToNetwork otn)
        {
            // Get the IP address of the server
            IPAddress IP = null;
            if (otn.Item is String)
            {
                if (!IPAddress.TryParse(otn.Item as String, out IP))
                    Log.Write(MethodBase.GetCurrentMethod(), "Could not convert '" + otn.Item + "' to a valid IP address", Log.LogType.Error);
            }
            else if (otn.Item is OutputToNetworkURI)
            {
                OutputToNetworkURI otnURI = otn.Item as OutputToNetworkURI;
                IPAddress[] IPs = Dns.GetHostAddresses(otnURI.Value);
                if (0 == IPs.Length)
                    Log.Write(MethodBase.GetCurrentMethod(), "Could not resolve '" + otnURI.Value + "' via DNS to a valid IP address", Log.LogType.Error);
                else if (1 == IPs.Length)
                    IP = IPs[0];
                else if (IPs.Length > 1)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Host '" + otnURI.Value + "' has " + IPs.Length + " IP addresses, finding one that works", Log.LogType.Info);
                    TcpClient client = new TcpClient();
                    for (int i = 0; i < IPs.Length; i++)
                    {
                        IPEndPoint oPossibleEndPoint = new IPEndPoint(IPs[i], (int)otn.Port);
                        try
                        {
                            client.Connect(oPossibleEndPoint);
                        }
                        catch (SocketException)
                        {
                            continue;
                        }
                        Log.Write(MethodBase.GetCurrentMethod(), "Using " + IPs[i].ToString(), Log.LogType.Info);
                        IP = IPs[i];
                        break;
                    }
                    if(null == IP)
                        Log.Write(MethodBase.GetCurrentMethod(), "Unable to connect on any of the IP addresses", Log.LogType.Error);
                }
            }
            else
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Unknown address type", Log.LogType.Error);
            }

            // Create the IP endpoint
            return new IPEndPoint(IP, (int)otn.Port);
        }

        private byte[] ReadResponse(TcpClient client, Stream NetStream)
        {
            byte[] Response = new byte[0];
            int bytes = -1;
            do
            {
                // The stream behaves differently if it is an SslStream or a NetworkStream.  An SslStream.Read will return 0 bytes if there is
                // nothing left to read (I assume as the connection is maintained), where NetworkStream.Read blocks on a read if there is nothing
                // left to read (I assume as the connection has been torn down).  This may not be accurate.
                //if ((NetStream is NetworkStream) && (!((NetStream as NetworkStream).DataAvailable)))
                if (!(client.GetStream() as NetworkStream).DataAvailable)
                {
                    int TimeOut = 100;
                    if (NetStream is SslStream)
                        TimeOut = 200;      // Wait longer for SSL traffic

                    // Wait for some data to become available
                    int Loop = (Response.Length > 0) ? 1 : 25;
                    for (int i = 0; i < Loop; i++)
                    {
                        if ((client.GetStream() as NetworkStream).DataAvailable)
                            break;
                        if (!client.Connected)
                            break;
                        System.Threading.Thread.Sleep(TimeOut);
                        System.Diagnostics.Debug.WriteLine("Waiting for a response (" + i + ")");
                        // If we have already read some bytes, don't wait the full timeout
                        //if ((i == 0) && (Response.Length != 0))
                        //    break;
                    }
                    if (!(client.GetStream() as NetworkStream).DataAvailable)
                        break;
                    if (!client.Connected)
                        break;
                }

                byte[] buffer = new byte[8192];

                bytes = NetStream.Read(buffer, 0, buffer.Length);

                // We have set a read timeout, so if we haven't read any bytes, break.
                if (0 == bytes)
                    break;

                // Copy to response
                int CurrentLength = Response.Length;
                Array.Resize<byte>(ref Response, Response.Length + bytes);
                Array.Copy(buffer, 0, Response, CurrentLength, bytes);
            }
            while (bytes != 0);
            return Response;
        }

        private MemoryStream CreateMessage(ProtocolDefinition Protocol, int MsgNum, OutputSettings oSettings)
        {
            ProtocolDefinitionMessage PDM = Protocol.Message[MsgNum];
            if (PDM.Item is string)
            {
                string FilePath = (PDM.Item as string);
                if (!File.Exists(FilePath))
                    Log.Write(MethodBase.GetCurrentMethod(), "Could not find raw data file '" + FilePath + "'", Log.LogType.Error);

                // We were given the raw path to the data to send
                byte[] FileBytes;
                using (FileStream fs = new FileStream(FilePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    FileBytes = new byte[fs.Length];
                    fs.Read(FileBytes, 0, (int)fs.Length);
                }
                return new MemoryStream(FileBytes);
            }
            else if (PDM.Item is ProtocolDefinitionMessageXMLMessage)
            {
                ProtocolDefinitionMessageXMLMessage XMLMessage = (PDM.Item as ProtocolDefinitionMessageXMLMessage);
                String XMLFilePath;
                // Get the path to the XML File
                if (XMLMessage.Item is AutoGenerated.Convert2XML)
                {
                    Fuzzware.Convert2XML.C2X.Convert2XML C2X = new Fuzzware.Convert2XML.C2X.Convert2XML(oSettings.XMLDoc.Schemas, oSettings.ObjectDB, oSettings.XmlSettings.Encoding);
                    if (!C2X.Convert(XMLMessage.Item as AutoGenerated.Convert2XML))
                        Log.Write(MethodBase.GetCurrentMethod(), "Convert2XML failed", Log.LogType.Error);
                    XMLFilePath = (XMLMessage.Item as AutoGenerated.Convert2XML).OutputXMLFile;
                }
                else
                {
                    XMLFilePath = XMLMessage.Item as string;
                }

                XmlDocument XmlDocMsg = XMLHelper.LoadAndCompileXML(XMLFilePath, oSettings.XMLDoc.Schemas, null);

                // TODO: If we need to update XML messages in a protocol before sending them, we would do it here.

                // Convert XML to raw output
                // Need to create new OutputSettings so the XMLDoc is the one we have just created
                OutputSettings ws = new OutputSettings(oSettings.Config);
                ws.ObjectDB = oSettings.ObjectDB;
                ws.XMLDoc = XmlDocMsg;
                MemoryStream XMLMemStream = new MemoryStream();

                // Create the stream that will hold the entire XML
                OutputWriter FuzzWriter = new OutputWriter(XMLMemStream, ws);
                XmlWriter Writer = XmlWriter.Create(FuzzWriter as XmlWriter, ws.XmlSettings);

                XmlDocMsg.WriteTo(Writer);
                Writer.Flush();

                // Copy the memory stream
                MemoryStream ReturnMS = new MemoryStream(XMLMemStream.ToArray());

                Writer.Close();

                // Write it to the output raw file path
                try
                {
                    using (FileStream fs = new FileStream(XMLMessage.OutputRawMessageFilePath, FileMode.Create, FileAccess.Write))
                    {
                        fs.Write(ReturnMS.ToArray(), 0, (int)ReturnMS.Length);
                    }
                }
                catch (Exception e)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Could not save raw output to file '" + XMLMessage.OutputRawMessageFilePath + "'\n" + e.Message, Log.LogType.Warning);
                }

                ReturnMS.Position = 0;
                return ReturnMS;
            }
            return null;
        }

        private XmlDocument ParseResponse(byte[] Response, ProtocolDefinition Protocol, int MsgNum, OutputSettings oSettings)
        {
            ProtocolDefinitionMessage PDM = Protocol.Message[MsgNum];
            if (PDM.Item is ProtocolDefinitionMessageXMLMessage)
            {
                ProtocolDefinitionMessageXMLMessage XMLMessage = (PDM.Item as ProtocolDefinitionMessageXMLMessage);

                if (XMLMessage.Item is AutoGenerated.Convert2XML)
                {
                    // Write out raw reponse to specified file
                    using (FileStream fs = new FileStream((XMLMessage.Item as AutoGenerated.Convert2XML).SourceFile, FileMode.Create, FileAccess.Write))
                    {
                        fs.Write(Response, 0, Response.Length);
                        fs.Flush();
                    }

                    // Convert to XML
                    Convert2XML.C2X.Convert2XML C2X = new Convert2XML.C2X.Convert2XML(oSettings.XMLDoc.Schemas, oSettings.ObjectDB, oSettings.XmlSettings.Encoding);
                    if (!C2X.Convert(XMLMessage.Item as AutoGenerated.Convert2XML))
                        Log.Write(MethodBase.GetCurrentMethod(), "Convert2XML failed", Log.LogType.Error);

                    return XMLHelper.LoadAndCompileXML((XMLMessage.Item as AutoGenerated.Convert2XML).OutputXMLFile, oSettings.XMLDoc.Schemas, null);
                }
                else
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "ServerToClient message must be Convert2XML", Log.LogType.Error);
                }
            }
            return null;
        }

        private bool CheckForErrorCondition(XmlDocument XMLDoc, ProtocolDefinition Protocol)
        {
            // Search the XML for any of the error nodes
            for (int i = 0; i < Protocol.ErrorMessage.Length; i++)
            {
                bool ErrorCondition = true;
                string[] NodeNames = Protocol.ErrorMessage[i];
                // Does the XML contain all of the following nodes
                for (int j = 0; j < NodeNames.Length; i++)
                {
                    XmlQualifiedName QName = new XmlQualifiedName(NodeNames[j], XMLDoc.DocumentElement.NamespaceURI);
                    XPathNavigator RootNode = XMLHelper.GetRootNode(XMLDoc);
                    XPathNavigator[] XPathNav = XMLHelper.SelectElementsOfType(RootNode, RootNode.Prefix, QName);
                    if ((null == XPathNav) || (XPathNav.Length == 0))
                    {
                        ErrorCondition = false;
                        break;
                    }
                }
                if (ErrorCondition)
                    return true;
            }
            return false;
        }

        public bool RunProtocol(ProtocolDefinition Protocol, OutputSettings oSettings)
        {
            // Do some input checking
            if (null == Protocol)
                Log.Write(MethodBase.GetCurrentMethod(), "No Protocol specified", Log.LogType.Error);

            if (null == oOutputToNetwork)
            {
                if (null != Protocol.OutputToNetwork)
                    oOutputToNetwork = Protocol.OutputToNetwork;
                else
                    Log.Write(MethodBase.GetCurrentMethod(), "No output to network settings specified", Log.LogType.Error);
            }

            // Record the endpoint to avoid a potential DNS query with each output
            if (null == EndPoint)
            {
                EndPoint = CreateEndPoint(oOutputToNetwork);
            }

            // Connect to the server
            if (null == client)
                client = new TcpClient();
            if (!client.Connected)
                client.Connect(EndPoint);

            if (!client.Connected)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Unable to connect to '" + EndPoint.Address.ToString() + "'", Log.LogType.Info);
                return false;
            }

            // Get the stream to write the network message to
            NetStream = GetOutputStream(client, oOutputToNetwork);

            // Run protocol
            byte[] Response = null;
            for (int i = 0; i < Protocol.Message.Length; i++)
            {
                // Check to see if we have reached the message we are fuzzing, if so break;
                if ((Protocol.Message[i].Item is ProtocolDefinitionMessageXMLMessage) &&
                    (Protocol.Message[i].Item as ProtocolDefinitionMessageXMLMessage).Fuzz)
                    break;

                if (Protocol.Message[i].Direction == ProtocolDefinitionMessageDirection.ClientToServer)
                {
                    // Create the memory stream of the message
                    MemoryStream XMLMemoryStream = CreateMessage(Protocol, i, oSettings);

                    // Write out our message
                    XMLMemoryStream.WriteTo(NetStream);
                    NetStream.Flush();

                    // Read in the response
                    Response = ReadResponse(client, NetStream);
                }
                else  // ServerToClient, read in response
                {
                    // Maybe the very first thing is the server sends data to the client on connect
                    if (i == 0)
                    {
                        // Read in the response
                        Response = ReadResponse(client, NetStream);
                    }

                    if (Response.Length > 0)
                    {
                        // Try to parse response
                        XmlDocument ResponseXMLDoc = ParseResponse(Response, Protocol, i, oSettings);

                        // Check it for error conditions.  We are expecting no errors.
                        if (CheckForErrorCondition(ResponseXMLDoc, Protocol))
                        {
                            return false;
                        }
                    }
                }
            }

            return true;
        }
    }
}
