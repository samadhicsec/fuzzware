using System;
using System.Collections.Generic;
using System.Text;
using System.Reflection;
using System.Threading;
using System.Diagnostics;
using System.Runtime.InteropServices;
using Fuzzware.Common;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Evaluate.FuzzwareDBG;

namespace Fuzzware.Evaluate
{
    public class ProcessProxy
    {
        static public ProcessProxy CreateProcessProxy(OutputToExe oOutputToExe)
        {
            if (oOutputToExe.ExePathAndName.UseDebugger)
                return new DebugProcessProxy(oOutputToExe);
            else
                return new ProcessProxy(oOutputToExe);
        }

        protected OutputToExe oOutputToExe;

        protected StringBuilder StdOutOutput;
        protected StringBuilder StdErrOutput;
        protected string ProcessOutputStr;
        protected bool bAppWasKilled;

        protected int ProcessDelay;
        protected int OpenDelay;
        protected int CloseDelay;
        protected bool bHasDefAppTermBehviourBeenSet = false;
        protected bool bAppTermSelfByDefault = false;

        Process OutputExe;
        protected uint PID;

        [DllImport("user32.dll")]
        static extern IntPtr GetForegroundWindow();
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool SetForegroundWindow(IntPtr hWnd);
        [DllImport("user32.dll", SetLastError = true)]
        static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        [DllImport("user32.dll", SetLastError = true)]
        static extern uint GetWindowThreadProcessId(IntPtr hWnd, out uint lpdwProcessId);
        

        public ProcessProxy(OutputToExe oOutputToExe)
        {
            this.oOutputToExe = oOutputToExe;

            ProcessDelay = (int)oOutputToExe.ProcessDelay;

            OpenDelay = 100;
            CloseDelay = 100;
            if (null != oOutputToExe.ExeOpenActions)
                OpenDelay = (int)oOutputToExe.ExeOpenActions.OpenDelayMilliSecs;
            else  // Use the default values
                OpenDelay = (int)(new OutputToExeExeOpenActions()).OpenDelayMilliSecs;
            if (null != oOutputToExe.ExeCloseActions)
                CloseDelay = (int)oOutputToExe.ExeCloseActions.CloseDelayMilliSecs;
            else  // Use the default values
                CloseDelay = (int)(new OutputToExeExeCloseActions()).CloseDelayMilliSecs;

        }

        //public string ExecuteCommand(string Command)
        //{
        //    string response;
        //    oIFuzzwareDBG.ExecuteCommand(Command, out response);
        //    return response;
        //}

        /// <summary>
        /// Checks if sendingProcess is FuzzwareDbg
        /// </summary>
        private bool IsFuzzwareDbg(object sendingProcess)
        {
            if (sendingProcess is Process)
            {
                String ProcessName = String.Empty;
                try
                {
                    ProcessName = (sendingProcess as Process).ProcessName;
                }
                catch { }
                if (!String.IsNullOrEmpty(ProcessName) && ProcessName.Equals("fuzzwaredbg.exe", StringComparison.CurrentCultureIgnoreCase))
                    return true; ;
            }
            return false;
        }

        private void StdOutOutputHandler(object sendingProcess, DataReceivedEventArgs outLine)
        {
            // Don't log FuzzwareDbg output
            if (IsFuzzwareDbg(sendingProcess))
                return;
            
            // Collect the sort command output.
            if (!String.IsNullOrEmpty(outLine.Data))
            {
                StdOutOutput.AppendLine(outLine.Data);
            }
        }

        private void StdErrOutputHandler(object sendingProcess, DataReceivedEventArgs outLine)
        {
            // Don't log FuzzwareDbg output
            if (IsFuzzwareDbg(sendingProcess))
                return;

            // Collect the sort command output.
            if (!String.IsNullOrEmpty(outLine.Data))
            {
                StdErrOutput.AppendLine(outLine.Data);
            }
        }

        #region Essentially IProcessProxy
        protected virtual void ProcessStart(String CommandLine, String StateDesc)
        {
            // Run Exe with command line parameters
            OutputExe = new Process();

            OutputExe.StartInfo.FileName = oOutputToExe.ExePathAndName.Value;
            OutputExe.StartInfo.Arguments = CommandLine;
            OutputExe.StartInfo.UseShellExecute = false;
            OutputExe.StartInfo.RedirectStandardOutput = true;
            OutputExe.StartInfo.RedirectStandardError = true;
            OutputExe.OutputDataReceived += new DataReceivedEventHandler(StdOutOutputHandler);
            OutputExe.ErrorDataReceived += new DataReceivedEventHandler(StdErrOutputHandler);
            StdOutOutput = new StringBuilder();
            StdErrOutput = new StringBuilder();
            
            // Execute!!
            OutputExe.Start();

            PID = (uint)OutputExe.Id;
        }

        protected virtual IntPtr GetMainWindowHandle()
        {
            return OutputExe.MainWindowHandle;
        }

        protected virtual void BeginReadOutput()
        {
            // Read the standard output and error of the Exe.
            OutputExe.BeginOutputReadLine();
            OutputExe.BeginErrorReadLine();
        }

        protected virtual String GetProcessOutput()
        {
            return StdOutOutput.ToString() + " " + StdErrOutput.ToString();
        }

        protected virtual void WaitForExit(int Delay)
        {
            OutputExe.WaitForExit(Delay);
        }

        protected virtual bool HasExited()
        {
            return OutputExe.HasExited;
        }

        protected virtual void ExitApp()
        {
            OutputExe.Refresh();
            OutputExe.CloseMainWindow();
            OutputExe.Refresh();
        }

        protected virtual void KillApp()
        {
            OutputExe.Kill();
        }

        protected virtual void Cleanup()
        {
            OutputExe.Close();
            OutputExe = null;
        }
        #endregion

        public void Run(String CommandLine, String StateDesc)
        {
            bAppWasKilled = false;

            // Start the process
            ProcessStart(CommandLine, StateDesc);

            //Now is an excellent time for a GC
            GC.Collect(GC.MaxGeneration);

            // Wait for the process
            Thread.Sleep(OpenDelay);

            // Process any window actions that occur at startup
            if ((null != oOutputToExe.ExeOpenActions) && (null != oOutputToExe.ExeOpenActions.OpenWindowAction))
                ProcessWindowActions(GetMainWindowHandle(), oOutputToExe.ExeOpenActions.OpenWindowAction);

            // Start reading any output of the application
            BeginReadOutput();

            // Wait for the process to exit, or for ProcessDelay amount of time.
            WaitForExit(ProcessDelay);

            if (!HasExited())
            {
                // If the default behaviour of the app is to terminate itself and it doesn't, this is not interesting unless we have to kill the
                // app, which will be detected (this reasoning is why this code block does not refer to bAppTermSelfByDefault)
                try
                {
                    ExitApp();
                    Thread.Sleep(CloseDelay);
                    if (!HasExited())
                    {
                        if ((null != oOutputToExe.ExeCloseActions) && (null != oOutputToExe.ExeCloseActions.CloseWindowAction))
                            ProcessWindowActions(GetMainWindowHandle(), oOutputToExe.ExeCloseActions.CloseWindowAction);

                        try
                        {
                            ExitApp();
                            WaitForExit(CloseDelay);
                        }
                        catch { }
                    }
                }
                catch (Exception e)
                {
                    Log.Write(MethodBase.GetCurrentMethod(), e.Message, Log.LogType.Warning);
                }

                if (!HasExited())
                {
                    bAppWasKilled = true;
                    try
                    {
                        // First look for iedw.exe, the IE7 Dr Watson, we need to get past this
                        CheckForIEDW(StateDesc);

                        KillApp();
                    }
                    catch { }
                    Thread.Sleep(1000);
                }
            }
            else
            {
                // If the default behaviour has not been set, then set it (this should happen only during the testcase)
                if (!bHasDefAppTermBehviourBeenSet)
                {
                    bAppTermSelfByDefault = true;
                    bHasDefAppTermBehviourBeenSet = true;
                    Log.Write(MethodBase.GetCurrentMethod(), "Schemer detected this application terminates itself (if this is not the case " +
                        "then the application needs to be given enough time to process the default testcase and terminate)", Log.LogType.LogOnlyInfo);
                }
                else
                {   // If the app does not normally terminate itself, but it has in this case, this is interesting.
                    if (!bAppTermSelfByDefault)
                        bAppWasKilled = true;
                }
            }

            // The process has finished running, so Close it to free up its resources
            Cleanup();

            bAppWasKilled = bAppWasKilled | CheckForCrashedProcess(StateDesc);

            ProcessOutputStr = GetProcessOutput();
        }

        public bool AppWasKilled()
        {
            return bAppWasKilled;
        }

        public String ProcessOutput()
        {
            return ProcessOutputStr;
        }

        //public void End()
        //{
        //    oIFuzzwareDBG = null;
        //}

        /// <summary>
        /// Send window actions to a window of a certain name, with the following conditions
        ///  - the window must have the same process id as the app window (on crashes the the crash window has the same name as the 
        ///  app window and that leads to confusion, so we differentiate by process id)
        ///  - if the window to receive the action is the main app window, send keys in another thread (if the main app is hung and we
        ///  send it keys then this process hangs waiting for the keys to be processed)
        /// </summary>
        private void ProcessWindowActions(IntPtr hParentWnd, WindowAction[] WindowActions)
        {
            if (null == WindowActions)
                return;
            //if (IntPtr.Zero == hParentWnd)
            //    return;

            int ProcessWindowActionCount = 0;
            uint TargetProcessId = PID;
            //uint TargetProcessId = 0;
            //GetWindowThreadProcessId(hParentWnd, out TargetProcessId);

            for (int i = 0; i < WindowActions.Length; i++)
            {
                IntPtr hWnd = FindWindow(null, WindowActions[i].WindowTitle);
                if (hWnd != IntPtr.Zero)
                {
                    uint WindowProcessId = 0;
                    GetWindowThreadProcessId(hWnd, out WindowProcessId);
                    if (WindowProcessId == TargetProcessId)
                    {
                        //Console.WriteLine("Found: " + WindowActions[i].WindowTitle);
                        if (null != WindowActions[i].KeyboardStrokes)
                        {
                            if (SetForegroundWindow(hWnd))
                            {
                                for (int j = 0; j < WindowActions[i].KeyboardStrokes.Length; j++)
                                {
                                    //if (hParentWnd != hWnd)
                                    //    System.Windows.Forms.SendKeys.SendWait(WindowActions[i].KeyboardStrokes[j]);
                                    //else
                                    //{
                                    // If the apps main window has the same name as the popup window and FindWindow returns the
                                    // main window, then it will send it messages instead of the pop-up.  Also, if the main app 
                                    // has hung, then SendWait will wait forever (I think) and Schemer will cause a CPU DoS. The
                                    // solution: if sending keys to the main window, do it in a seperate thread
                                    ThreadedSendKey(WindowActions[i].KeyboardStrokes[j]);
                                    //}
                                }
                            }
                            else
                                Log.Write(MethodBase.GetCurrentMethod(), "Could not set foreground window", Log.LogType.Warning);
                        }
                        // We processed a window action, but keep on trying to process other window actions as well.  We include
                        // a limit on this to avoid any degenerate case.
                        if (ProcessWindowActionCount++ < 5)
                            i = 0;
                        else
                            break;
                    }
                    //break;
                }
            }

        }

        private void ThreadedSendKey(String Key)
        {
            ParameterizedThreadStart pts = new ParameterizedThreadStart(ThreadedSendKeyMethod);
            Thread SendKeyThread = new Thread(pts);
            SendKeyThread.Start(Key);
            //System.Windows.Forms.SendKeys.Send(WindowActions[i].KeyboardStrokes[j]);
            Thread.Sleep(500);
            if (SendKeyThread.IsAlive)
            {
                Thread.Sleep(500);
                SendKeyThread.Abort();
            }
        }

        private void ThreadedSendKeyMethod(object o)
        {
            try
            {
                System.Windows.Forms.SendKeys.SendWait(o as string);
            }
            catch { }
        }

        private bool CheckForCrashedProcess(String StateDesc)
        {
            // On XP we look for ...
            if (CheckForWatson(StateDesc))
                return true;

            // On Vista we look for ...
            if (CheckForWER(StateDesc))
                return true;

            return false;
        }

        /// <summary>
        /// Checks if iedw.exe is running, if so, assumes a crash.
        /// </summary>
        private void CheckForIEDW(String StateDesc)
        {
            Process[] oProcesses = Process.GetProcessesByName("iedw");
            if (0 == oProcesses.Length)
                return;

            // Set the dwwin to be the forground window, and send it an 'Enter' to close it
            for (int i = 0; i < oProcesses.Length; i++)
            {
                try
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Closing iedw.exe window for state '" + StateDesc + "'", Log.LogType.Info);

                    SetForegroundWindow(oProcesses[i].MainWindowHandle);
                    ThreadedSendKey("{Tab}");
                    ThreadedSendKey("{Tab}");
                    ThreadedSendKey("{Tab}");
                    ThreadedSendKey("{Enter}");

                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].CloseMainWindow();
                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].Kill();
                    oProcesses[i].Close();
                }
                catch { }
            }
        }

        /// <summary>
        /// Checks if dwwin.exe is running, if so, assumes a crash.
        /// </summary>
        /// <returns>True if a crash is detected, false otherwise</returns>
        private bool CheckForWatson(String StateDesc)
        {
            Process[] oProcesses = Process.GetProcessesByName("dwwin");
            if (0 == oProcesses.Length)
                return false;

            // Set the dwwin to be the forground window, and send it an 'Enter' to close it
            for (int i = 0; i < oProcesses.Length; i++)
            {
                try
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Closing Dr Watson window for state '" + StateDesc + "'", Log.LogType.Info);

                    SetForegroundWindow(oProcesses[i].MainWindowHandle);
                    ThreadedSendKey("{Enter}");

                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].CloseMainWindow();
                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].Kill();
                    oProcesses[i].Close();
                }
                catch { }
            }
            return true;
        }

        /// <summary>
        /// Checks if WerFault.exe is running, if so, assumes a crash.
        /// </summary>
        /// <returns>True if a crash is detected, false otherwise</returns>
        private bool CheckForWER(String StateDesc)
        {
            Process[] oProcesses = Process.GetProcessesByName("WerFault");
            if (0 == oProcesses.Length)
                return false;

            // Set the dwwin to be the forground window, and send it an 'Enter' to close it
            for (int i = 0; i < oProcesses.Length; i++)
            {
                try
                {
                    Log.Write(MethodBase.GetCurrentMethod(), "Closing WER window for state '" + StateDesc + "'", Log.LogType.Info);

                    IntPtr hWindowHandle = FindWindow(null, oProcesses[i].MainWindowTitle);
                    if (null != hWindowHandle)
                    {
                        SetForegroundWindow(hWindowHandle);
                        ThreadedSendKey("{Enter}");
                    }
                    else
                    {
                        SetForegroundWindow(oProcesses[i].MainWindowHandle);
                        ThreadedSendKey("{Enter}");
                    }

                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].CloseMainWindow();
                    Thread.Sleep(1000);
                    if (!oProcesses[i].HasExited)
                        oProcesses[i].Kill();
                    oProcesses[i].Close();
                }
                catch { }
            }
            return true;
        }
    }
}
