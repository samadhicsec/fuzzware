using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using Fuzzware.Schemas.AutoGenerated;

namespace Fuzzware.Common.UserCode
{
    public class UserDefinedCodeComparer : IEqualityComparer<UserDefinedCode>
    {
        #region IEqualityComparer<UserDefinedCode> Members

        public bool Equals(UserDefinedCode x, UserDefinedCode y)
        {
            // Compare assemblies
            if (x.LoadAssembly.Length != y.LoadAssembly.Length)
                return false;
            for (int i = 0; i < x.LoadAssembly.Length; i++)
                if (!x.LoadAssembly[i].Equals(y.LoadAssembly[i], StringComparison.CurrentCultureIgnoreCase))
                    return false;

            // Compare namespace.class
            if (!x.NamespaceDotClass.Equals(y.NamespaceDotClass, StringComparison.CurrentCulture))
                return false;

            // We don't care is the user defined data is different

            return true;
        }

        public int GetHashCode(UserDefinedCode obj)
        {
            // This should work, as apparently String.GetHashCode() will return different hash codes for different strings and
            // return the same hash code for the same strings.
            int hashcode = 0;
            for (int i = 0; i < obj.LoadAssembly.Length; i++)
                hashcode += obj.LoadAssembly[i].GetHashCode();
            hashcode += obj.NamespaceDotClass.GetHashCode();
            return hashcode;
        }

        #endregion
    }

    public class CodeLoader
    {
        public static T LoadUserCode<T>(UserDefinedCode oUserDefinedCode)
        {
            // Load the assembly
            Assembly[] oAssemblies = new Assembly[oUserDefinedCode.LoadAssembly.Length];
            for (int i = 0; i < oUserDefinedCode.LoadAssembly.Length; i++)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "Loading user Assembly '" + oUserDefinedCode.LoadAssembly[i] + "'", Log.LogType.Info);
                oAssemblies[i] = Assembly.LoadFrom(Path.GetFullPath(oUserDefinedCode.LoadAssembly[i]));
            }

            // Create the class
            Assembly ClassAssembly = null;
            for (int i = 0; i < oAssemblies.Length; i++)
            {
                bool bFoundType = false;
                // TODO: GetExportedTypes can apparently throw a System.TypeLoadException, should catch and skip assembly.
                Type[] AssemblyTypes = oAssemblies[i].GetExportedTypes();
                for (int j = 0; j < AssemblyTypes.Length; j++)
                {
                    if (AssemblyTypes[j].ToString() == oUserDefinedCode.NamespaceDotClass)
                    {
                        bFoundType = true;
                        ClassAssembly = oAssemblies[i];
                        break;
                    }
                }
                if (bFoundType)
                    break;
            }
            if (null == ClassAssembly)
                Log.Write(MethodBase.GetCurrentMethod(), "Could not find type '" + oUserDefinedCode.NamespaceDotClass + "' among the assemblies exported types.", Log.LogType.Error);
            else
                Log.Write(MethodBase.GetCurrentMethod(), "Found '" + oUserDefinedCode.NamespaceDotClass + "' in '" + Path.GetFileName(ClassAssembly.Location) + "'", Log.LogType.Info);

            Log.Write(MethodBase.GetCurrentMethod(), "Creating instance of '" + oUserDefinedCode.NamespaceDotClass + "'", Log.LogType.Info);
            object oReturn = null;
            try
            {
                oReturn = (T)ClassAssembly.CreateInstance(oUserDefinedCode.NamespaceDotClass);
            }
            catch (Exception e)
            {
                System.Diagnostics.Debug.WriteLine(e.Message);
                Log.Write(MethodInfo.GetCurrentMethod(), "Could not create an instance of '" + oUserDefinedCode.NamespaceDotClass + "'.\n" + e.Message, Log.LogType.Error);
            }
            return (T)oReturn;
        }
    }
}
