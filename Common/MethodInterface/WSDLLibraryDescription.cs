using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Web.Services.Description;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Schemas.AutoGenerated;

namespace Fuzzware.Common.MethodInterface
{
    /// <summary>
    /// WSDLLibraryDescription converts a WSDL into a LibraryDescription object
    /// </summary>
    public class WSDLLibraryDescription : LibraryDescription
    {
        /// <summary>
        /// The format of the body of the WSDL message
        /// </summary>
        protected WSDLInputProtocol m_eProtocol;
        /// <summary>
        /// A list of schemas that do not already exist on disk
        /// </summary>
        protected List<String> m_oNonExistingSchema;
        /// <summary>
        /// The WSDL service to Namespace dictionary
        /// </summary>
        protected Dictionary<string, string> m_oServiceNSDictionary;
        /// <summary>
        /// The directory to store any created files
        /// </summary>
        protected String m_OutputDir;

        protected WSDLLibraryDescription(MethodsConfig oMethodsConfiguration)
            : base(oMethodsConfiguration)
        { m_oServiceNSDictionary = new Dictionary<string, string>(); m_oNonExistingSchema = new List<string>(); }

        public WSDLLibraryDescription(String[] WSDLPathAndFile, WSDLInputProtocol Protocol, MethodsConfig oMethodsConfiguration, String OutputDir)
            : base(oMethodsConfiguration)
        {
            m_oServiceNSDictionary = new Dictionary<string, string>();
            m_oNonExistingSchema = new List<string>();
            LoadWSDL(WSDLPathAndFile, Protocol);
            m_OutputDir = OutputDir;
            if (null == m_OutputDir)
                m_OutputDir = "";
        }

        public WSDLInputProtocol Protocol
        {
            get { return m_eProtocol; }
        }

        /// <summary>
        /// Returns true if the schema with this Namespace already pre-exists on disk i.e. whether it needs to be created.  If it doesn't 
        /// then it can be written to disk which means it can be regenerated.
        /// </summary>
        public bool IsPreExisting(string Namespace)
        {
            if (m_oNonExistingSchema.Contains(Namespace))
                return false;
            return true;
        }

        /// <summary>
        /// Convert the input WSDL into the internal representation
        /// </summary>
        protected void LoadWSDL(String[] WSDLPathAndFiles, WSDLInputProtocol Protocol)
        {
            oNamespacetoXSDDictionary = new Dictionary<string, string>();
            oNamespacetoXmlSchemaDictionary = new Dictionary<string, XmlSchema>();

            m_eProtocol = Protocol;

            List<string> oWSDLPathAndFiles = new List<string>(WSDLPathAndFiles);
            ServiceDescription sd = CombineAndCreateServiceDescription(oWSDLPathAndFiles);

            // Set the name of the Service.  By default assume there are multiple WSDLs or multiple services.
            LibraryName = "MultipleWebServiceMethods";
            if (1 == sd.Services.Count)
                LibraryName = sd.Services[0].Name;  // If there is only one Service, use it's name.
            // Set the namespace of the library
            LibraryNS = sd.TargetNamespace;
            
            // oNSManager contains all the namespaces referenced by each input WSDL
            // Add all the namespaces referenced by the input WSDL schemas
            if (null != sd.Types.Schemas)
            {
                for (int i = 0; i < sd.Types.Schemas.Count; i++)
                {
                    m_oNonExistingSchema.Add(sd.Types.Schemas[i].TargetNamespace);
                    // Make sure all schemas use elementFormDefault="qualified"
                    sd.Types.Schemas[i].ElementFormDefault = XmlSchemaForm.Qualified;
                    XmlQualifiedName[] oNamespaces = sd.Types.Schemas[i].Namespaces.ToArray();
                    for (int j = 0; j < oNamespaces.Length; j++)
                    {
                        if (String.IsNullOrEmpty(oNSManager.LookupPrefix(oNamespaces[j].Namespace)))
                            oNSManager.AddNamespace(oNamespaces[j].Name, oNamespaces[j].Namespace);
                    }
                    // Populate Namespace to XmlSchema dictionary
                    if (!oNamespacetoXmlSchemaDictionary.ContainsKey(sd.Types.Schemas[i].TargetNamespace))
                    {
                        // Make note of where the schema is, or where we will write it
                        oNamespacetoXSDDictionary.Add(sd.Types.Schemas[i].TargetNamespace, GetFilenameFromSchemaNS(m_OutputDir, sd.Types.Schemas[i].TargetNamespace,
                            sd.TargetNamespace.Equals(sd.Types.Schemas[i].TargetNamespace)));
                        // If the schema exists on disk, re-use it.
                        if(!File.Exists(oNamespacetoXSDDictionary[sd.Types.Schemas[i].TargetNamespace]))
                            oNamespacetoXmlSchemaDictionary.Add(sd.Types.Schemas[i].TargetNamespace, sd.Types.Schemas[i]);
                        else
                            using (FileStream fs = new FileStream(oNamespacetoXSDDictionary[sd.Types.Schemas[i].TargetNamespace], FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                            {
                                XmlSchema oSchema = XmlSchema.Read(fs, SchemaValidationEventHandler);
                                oNamespacetoXmlSchemaDictionary.Add(sd.Types.Schemas[i].TargetNamespace, oSchema);
                            }
                    }
                    else
                        Log.Write(MethodBase.GetCurrentMethod(), "There is more than 1 WSDL Types schema with a target namespace of '" +
                            sd.Types.Schemas[i].TargetNamespace + "', ignoring.", Log.LogType.Warning);
                }
            }
            // For each schema in oNStoXmlSchemaDictionary, add any imports where the location is defined
            Dictionary<string, XmlSchema> oImportedSchemas = new Dictionary<string, XmlSchema>();
            foreach (KeyValuePair<string, XmlSchema> oKeyValuePair in oNamespacetoXmlSchemaDictionary)
            {
                AddSchemaWithImports(oKeyValuePair.Value, oImportedSchemas);
            }
            // Add imported schemas to our list of schemas
            foreach (KeyValuePair<string, XmlSchema> oKeyValuePair in oImportedSchemas)
            {
                oNamespacetoXmlSchemaDictionary.Add(oKeyValuePair.Key, oKeyValuePair.Value);
            }

            // Check all the imported schemas of all our currently listed schema, and tell the user about any that are missing.  Also,
            // update the location of any import that does not have a location
            foreach(KeyValuePair<string, XmlSchema> oKeyValuePair in oNamespacetoXmlSchemaDictionary)
            {
                XmlSchema oXmlSchema = oKeyValuePair.Value;
                if ((null != oXmlSchema.Includes))
                {
                    foreach (XmlSchemaObject obj in oXmlSchema.Includes)
                    {
                        // We ignore Includes because they only have a location, this could be a problem if the location is a URL
                        if (obj is XmlSchemaImport)
                        {
                            XmlSchemaImport oSchemaImport = obj as XmlSchemaImport;
                            if (!oNamespacetoXmlSchemaDictionary.ContainsKey(oSchemaImport.Namespace))
                                Log.Write(MethodBase.GetCurrentMethod(), "The namespace '" + oSchemaImport.Namespace + "' imported by '" +
                                    oKeyValuePair.Key + "' is not the target namespace of any schema or imported schema in the WSDL", Log.LogType.Warning);
                            if (String.IsNullOrEmpty(oSchemaImport.SchemaLocation) && oNamespacetoXSDDictionary.ContainsKey(oSchemaImport.Namespace))
                                oSchemaImport.SchemaLocation = oNamespacetoXSDDictionary[oSchemaImport.Namespace];
                        }
                    }
                }
            }

            // At this stage we should have a Dictionary of all namespaces and XmlSchema (not quite true since Methods may be from an
            // arbitrary other namespace).  Potentially the target namespace of the WSDL does not have a schema, in which lets create 
            // one for it and add it to our list (as we may need to write method to it).
            if (!oNamespacetoXmlSchemaDictionary.ContainsKey(sd.TargetNamespace))
            {
                // This will add all the other schemas as imports
                CreateAndAddSchema(sd.TargetNamespace, sd);
            }
            else
            {
                AddAllImportedSchema(sd.TargetNamespace);
            }

            // Set the Schemas
            oMethodSchemas = sd.Types.Schemas;

            // Populate the interface definitions
            LoadInterfaces(sd);

            // The goal now is to get all our methods defined in their respective schemas.
            // Go through each method and add an element to an existing schema (the method might already exist without
            // the interface prefix, in which case we must update the method name)
            for (int i = 0; i < oInterfaceDescriptions.Count; i++)
            {
                for (int j = 0; j < oInterfaceDescriptions[i].Methods.Count; j++)
                {
                    string NSofMethod = (oInterfaceDescriptions[i].Methods[j] as WSDLMethodDescription).InputMessageNamespace;
                    if (!oNamespacetoXmlSchemaDictionary.ContainsKey(NSofMethod))
                    {
                        // It is possible that all/some of the WSDL methods are assigned to a namespace we have not seen yet
                        CreateAndAddSchema(NSofMethod, sd);
                        // Import this schema into the WSDL target schema
                        XmlSchemaImport oNewXmlSchemaImport = new XmlSchemaImport();
                        oNewXmlSchemaImport.Namespace = NSofMethod;
                        oNewXmlSchemaImport.SchemaLocation = oNamespacetoXSDDictionary[NSofMethod];
                        oNamespacetoXmlSchemaDictionary[sd.TargetNamespace].Includes.Add(oNewXmlSchemaImport);
                    }
                    oInterfaceDescriptions[i].CreateMethodSchemaElement(oNamespacetoXmlSchemaDictionary[NSofMethod], j);
                }
            }

            // Now all the methods should exist and they should exist in the schema with the target namespace that corresponds to the
            // namespace of the method.  We now need to add the Methods root node to the schema with the WSDL target namespace.
            AddLibraryDescriptionToSchema(oNamespacetoXmlSchemaDictionary[sd.TargetNamespace]);
        }

        /// <summary>
        /// Create a new schema and add it to oNamespacetoXmlSchemaDictionary and oNamespacetoXSDDictionary.  If a ServiceDescription
        /// is passed in import all the Types schemas
        /// </summary>
        protected void CreateAndAddSchema(String TargetNamespace, ServiceDescription sd)
        {
            XmlSchema oNewXmlSchema = new XmlSchema();
            oNewXmlSchema.TargetNamespace = TargetNamespace;
            // Make sure all schemas use elementFormDefault="qualified"
            oNewXmlSchema.ElementFormDefault = XmlSchemaForm.Qualified;
            oNamespacetoXmlSchemaDictionary.Add(TargetNamespace, oNewXmlSchema);
            oNamespacetoXSDDictionary.Add(TargetNamespace, GetFilenameFromSchemaNS(m_OutputDir, TargetNamespace, TargetNamespace.Equals(sd.TargetNamespace)));
            m_oNonExistingSchema.Add(TargetNamespace);

            // Add the WSDL Types schemas as imports
            AddAllImportedSchema(TargetNamespace);
        }

        /// <summary>
        /// Adds all the imported schema to the schema with Namepsace
        /// </summary>
        private void AddAllImportedSchema(String Namespace)
        {
            XmlSchema oTargetSchema = oNamespacetoXmlSchemaDictionary[Namespace];
            // Since we don't know what the schema will end up needing to reference, import all schemas
            foreach (KeyValuePair<string, XmlSchema> oKeyValuePair in oNamespacetoXmlSchemaDictionary)
            {
                // Don't try to import ourselves
                if (!Namespace.Equals(oKeyValuePair.Key))
                {
                    bool bAlreadyImported = false;
                    // Check this schema isn't already imported
                    for (int i = 0; i < oTargetSchema.Includes.Count; i++)
                        if ((oTargetSchema.Includes[i] is XmlSchemaImport) && (oTargetSchema.Includes[i] as XmlSchemaImport).Namespace.Equals(oKeyValuePair.Key))
                        {
                            bAlreadyImported = true;
                            break;
                        }
                    if (!bAlreadyImported)
                    {
                        XmlSchemaImport oXmlSchemaImport = new XmlSchemaImport();
                        oXmlSchemaImport.Namespace = oKeyValuePair.Key;
                        oXmlSchemaImport.SchemaLocation = oNamespacetoXSDDictionary[oXmlSchemaImport.Namespace];
                        oNamespacetoXmlSchemaDictionary[Namespace].Includes.Add(oXmlSchemaImport);
                    }
                }
            }
        }

        protected virtual void LoadInterfaces(ServiceDescription sd)
        {
            oInterfaceDescriptions = new List<InterfaceDescription>();

            for (int i = 0; i < sd.Services.Count; i++)
            {
                WSDLInterfaceDescription oWSDLInterfaceDescription = new WSDLInterfaceDescription(sd.Services[i], m_eProtocol, m_oServiceNSDictionary[sd.Services[i].Name], oNamespacetoXmlSchemaDictionary);
                oInterfaceDescriptions.Add(oWSDLInterfaceDescription);
            }
        }

        /// <summary>
        /// For the passed in XmlSchema, load any imports that have a location and store them in oImportedSchemas.  Check the XmlSchema do
        /// not already exist in oNStoXmlSchemaDictionary or oImportedSchemas.  We also record the location of the schemas.
        /// </summary>
        protected void AddSchemaWithImports(XmlSchema oXmlSchema, Dictionary<string, XmlSchema> oImportedSchemas)
        {
            if (null != oXmlSchema.Includes)
            {
                foreach (XmlSchemaObject obj in oXmlSchema.Includes)
                {
                    // We ignore Includes because they only have a location, this could be a problem if the location is a URL
                    if (obj is XmlSchemaImport)
                    {
                        XmlSchemaImport oSchemaImport = obj as XmlSchemaImport;
                        if (!oNamespacetoXmlSchemaDictionary.ContainsKey(oSchemaImport.Namespace) && 
                            !oImportedSchemas.ContainsKey(oSchemaImport.Namespace) &&
                            !String.IsNullOrEmpty(oSchemaImport.SchemaLocation))
                        {
                            // Try and load the imported schema
                            if (File.Exists(oSchemaImport.SchemaLocation))
                            {
                                using(FileStream fs = new FileStream(oSchemaImport.SchemaLocation, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                                {
                                    XmlSchema ImportSchema = XmlSchema.Read(fs, SchemaValidationEventHandler);
                                    oImportedSchemas.Add(oSchemaImport.Namespace, ImportSchema);
                                    // Add the imported schema to out Namespace-to-XSD dictinary
                                    if(!oNamespacetoXSDDictionary.ContainsKey(oSchemaImport.Namespace))
                                        oNamespacetoXSDDictionary.Add(oSchemaImport.Namespace, oSchemaImport.SchemaLocation);
                                    // Add any new namespaces declared in this new schema
                                    XmlQualifiedName[] oNamespaces = ImportSchema.Namespaces.ToArray();
                                    for (int j = 0; j < oNamespaces.Length; j++)
                                    {
                                        if (String.IsNullOrEmpty(oNSManager.LookupPrefix(oNamespaces[j].Namespace)))
                                            oNSManager.AddNamespace(oNamespaces[j].Name, oNamespaces[j].Namespace);
                                    }
                                }
                                // This new imported schema may import more schemas, so lets recurse.
                                AddSchemaWithImports(oImportedSchemas[oSchemaImport.Namespace], oImportedSchemas);
                            }
                        }
                    }
                }
            }
        }
        private void SchemaValidationEventHandler(Object sender, ValidationEventArgs e)
        {
            
        }

        /// <summary>
        /// Combine all the input WSDLs into one big WSDL
        /// </summary>
        protected ServiceDescription CombineAndCreateServiceDescription(List<String> WSDLPathAndFiles)
        {
            ServiceDescription sd = null;
            int iCounter = WSDLPathAndFiles.Count + 1;

            for (int i = 0; i < WSDLPathAndFiles.Count; i++)
            {
                try
                {
                    using (FileStream fs = new FileStream(WSDLPathAndFiles[i], FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                    {
                        if (null == sd)
                        {
                            // Load the WSDL file describing a service
                            sd = ServiceDescription.Read(fs);
                            
                            // Record all the namespaces referenced by the WSDL, as these will often be referenced by the Types Schemas
                            XmlQualifiedName[] oNamespaces = sd.Namespaces.ToArray();
                            for (int j = 0; j < oNamespaces.Length; j++)
                                oNSManager.AddNamespace(oNamespaces[j].Name, oNamespaces[j].Namespace);

                            // Add to the Service/Namespace dictionary
                            for (int j = 0; j < sd.Services.Count; j++)
                                m_oServiceNSDictionary.Add(sd.Services[j].Name, sd.TargetNamespace);

                            // If we have multiple WSDLs then change the target namespace.  We need to update the namespace of each method
                            // then to ensure that the method schema elements come from the correct namespace
                            if (WSDLPathAndFiles.Count > 1)
                            {
                                for(int j = 0; j < sd.Bindings.Count; j++)
                                    UpdateMethodNamespacesOnBinding(sd.Bindings[j], sd.TargetNamespace);
                                
                                sd.TargetNamespace = "MultipleWebServiceMethods";
                            }
                        }
                        else
                        {
                            // Combine ServiceDescription
                            ServiceDescription oSrvDesc = ServiceDescription.Read(fs);

                            // Add any namespaces not already declared
                            List<XmlQualifiedName> oNewNSs = new List<XmlQualifiedName>(oSrvDesc.Namespaces.ToArray());
                            // Make sure we add the targetnamespace
                            bool bTargetNSExists = false;
                            for (int j = 0; j < oNewNSs.Count && !bTargetNSExists; j++)
                                if (oNewNSs[j].Namespace.Equals(oSrvDesc.TargetNamespace))
                                    bTargetNSExists = true;
                            if(!bTargetNSExists)
                                oNewNSs.Add(new XmlQualifiedName("svc" + (i+1), oSrvDesc.TargetNamespace));

                            foreach (XmlQualifiedName oNS in oNewNSs)
                            {
                                // Has this namespace already been declared?
                                String prefix = oNSManager.LookupPrefix(oNS.Namespace);
                                if (String.IsNullOrEmpty(prefix))
                                {
                                    // The prefix is empty, so the namepsace has not been declared already, so we need to add it
                                    if (String.IsNullOrEmpty(oNSManager.LookupNamespace(oNS.Name)))
                                    {
                                        // The prefix of the namespace we want to add does not already exist, so we can safely add them
                                        oNSManager.AddNamespace(oNS.Name, oNS.Namespace);
                                        sd.Namespaces.Add(oNS.Name, oNS.Namespace);
                                    }
                                    else
                                    {
                                        // The prefix of the namespace we want to add already exists.
                                        // There could be many things in the Types schema that use this namespace, and we don't want
                                        // to try and update them all, so lets fail
                                        //Log.Write(MethodBase.GetCurrentMethod(), "Cannot combine '" + WSDLPathAndFiles[i] + "' as it uses a " +
                                        //    "namespace '" + oNS.Namespace + "' with the prefix '" + oNS.Name + "' which is already in use by the " +
                                        //    "namespace '" + oNSManager.LookupNamespace(oNS.Name) + "'.  Update '" + WSDLPathAndFiles[i] + "' to " +
                                        //    "use a different prefix for '" + oNS.Namespace + "'", Log.LogType.Error);
                                        
                                        // The prefix of the namespace we want to add already exists.  We can safely change it though as 
                                        // it can remain the same in it's own schema and we only look in that schema when we resolve method
                                        // elements.  It will be different in new schemas, but that's fine.
                                        oNSManager.AddNamespace(oNS.Name + iCounter, oNS.Namespace);
                                        sd.Namespaces.Add(oNS.Name + iCounter++, oNS.Namespace);
                                    }
                                }
                            }
                            
                            // Add all the sections of the WSDL
                            for (int j = 0; j < oSrvDesc.Types.Schemas.Count; j++)
                            {
                                // If we already have a schema with that TargetNamespace then we don't add the schema.
                                // EC: It's perfectly legal to have to completely independant schemas with the same target namespace,
                                // however we assume it's more common that a schema will be repeated in 2 different WSDL's and so
                                // we try to identify these by target namespace.
                                if (!sd.Types.Schemas.Contains(oSrvDesc.Types.Schemas[j].TargetNamespace))
                                    sd.Types.Schemas.Add(oSrvDesc.Types.Schemas[j]);
                                else
                                {
                                    // TODO: Add all the items in this schema to the existing one with the same namespace
                                    // Add all namespace references
                                    // Find a way not to add duplicate items.  Will probably need to identify the type of each.  Could
                                    // be a lot of code.  May be able to use the existing NameTable.  May be able to import/include.
                                    //XmlSchema oExistingXmlSchema = sd.Types.Schemas[oSrvDesc.Types.Schemas[j].TargetNamespace];
                                    //XmlSchema oCurrentXmlSchema = oSrvDesc.Types.Schemas[j];
                                    //for (int k = 0; k < oCurrentXmlSchema.Items.Count; k++)
                                    //{
                                    //    try
                                    //    {
                                    //        oExistingXmlSchema.Items.Add(oCurrentXmlSchema.Items[k]);
                                    //    }
                                    //    catch (Exception e)
                                    //    {
                                    //        Log.Write(MethodBase.GetCurrentMethod(), e.Message, Log.LogType.Warning);
                                    //    }
                                    //}
                                }
                            }
                            for (int j = 0; j < oSrvDesc.Messages.Count; j++)
                                sd.Messages.Add(oSrvDesc.Messages[j]);
                            for (int j = 0; j < oSrvDesc.PortTypes.Count; j++)
                                sd.PortTypes.Add(oSrvDesc.PortTypes[j]);
                            for (int j = 0; j < oSrvDesc.Bindings.Count; j++)
                            {
                                // We need to alter the namespace on the Binding/Operation/input|output/soap:body so we do not lose
                                // what target namespace each method belongs to
                                UpdateMethodNamespacesOnBinding(oSrvDesc.Bindings[j], oSrvDesc.TargetNamespace);
                                sd.Bindings.Add(oSrvDesc.Bindings[j]);
                            }
                            for (int j = 0; j < oSrvDesc.Services.Count; j++)
                            {
                                sd.Services.Add(oSrvDesc.Services[j]);
                                // Add to the Service/Namespace dictionary
                                if (m_oServiceNSDictionary.ContainsKey(oSrvDesc.Services[j].Name))
                                    Log.Write(MethodBase.GetCurrentMethod(), "Amongst all the input WSDLs no 2 services can have the same name", Log.LogType.Error);
                                m_oServiceNSDictionary.Add(oSrvDesc.Services[j].Name, oSrvDesc.TargetNamespace);
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Log.Write(e);
                }
            }
            return sd;
        }

        /// <summary>
        /// Update the namespace on the Binding/Operation/input|output/soap:body so we do not lose what target 
        /// namespace each method belongs to
        /// </summary>
        /// <param name="oBinding">The binding to update</param>
        /// <param name="Namespace">The namespace to set on each message that has an empty namespace</param>
        private void UpdateMethodNamespacesOnBinding(Binding oBinding, String Namespace)
        {
            for (int i = 0; i < oBinding.Operations.Count; i++)
            {
                OperationBinding oOperationBinding = oBinding.Operations[i];
                if ((null != oOperationBinding.Input) && (oOperationBinding.Input.Extensions.Count > 0))
                {
                    for (int j = 0; j < oOperationBinding.Input.Extensions.Count; j++)
                    {
                        if (oOperationBinding.Input.Extensions[j].GetType() == typeof(Soap12BodyBinding))
                        {
                            Soap12BodyBinding oSoap12BodyBinding = (Soap12BodyBinding)oOperationBinding.Input.Extensions[j];
                            if (String.IsNullOrEmpty(oSoap12BodyBinding.Namespace))
                                oSoap12BodyBinding.Namespace = Namespace;
                        }
                        if (oOperationBinding.Input.Extensions[j].GetType() == typeof(SoapBodyBinding))
                        {
                            SoapBodyBinding oSoapBodyBinding = (SoapBodyBinding)oOperationBinding.Input.Extensions[j];
                            if (String.IsNullOrEmpty(oSoapBodyBinding.Namespace))
                                oSoapBodyBinding.Namespace = Namespace;
                        }
                    }
                }
                if ((null != oOperationBinding.Output) && (oOperationBinding.Output.Extensions.Count > 0))
                {
                    for (int j = 0; j < oOperationBinding.Output.Extensions.Count; j++)
                    {
                        if (oOperationBinding.Output.Extensions[j].GetType() == typeof(Soap12BodyBinding))
                        {
                            Soap12BodyBinding oSoap12BodyBinding = (Soap12BodyBinding)oOperationBinding.Output.Extensions[j];
                            if (String.IsNullOrEmpty(oSoap12BodyBinding.Namespace))
                                oSoap12BodyBinding.Namespace = Namespace;
                        }
                        if (oOperationBinding.Output.Extensions[j].GetType() == typeof(SoapBodyBinding))
                        {
                            SoapBodyBinding oSoapBodyBinding = (SoapBodyBinding)oOperationBinding.Output.Extensions[j];
                            if (String.IsNullOrEmpty(oSoapBodyBinding.Namespace))
                                oSoapBodyBinding.Namespace = Namespace;
                        }
                    }
                }
            }
        }
    }
}
