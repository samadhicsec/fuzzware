using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.XPath;
using System.Xml.Serialization;
using Fuzzware.Common.XML;
using Fuzzware.Schemas.AutoGenerated;

namespace Fuzzware.Common.MethodInterface
{
    /// <summary>
    /// Describes a Library which is a collection of Interfaces.  This class is used to convert this internal representation
    /// into an XSD file describing the Library.
    /// </summary>
    public class LibraryDescription
    {
        protected String LibraryName;
        protected String LibraryNS;
        protected XmlNamespaceManager oNSManager;
        protected List<InterfaceDescription> oInterfaceDescriptions;

        protected Dictionary<string, string> oNamespacetoXSDDictionary;
        protected Dictionary<string, XmlSchema> oNamespacetoXmlSchemaDictionary;

        protected XmlSchemas oMethodSchemas;
        protected bool bUseSeperateLibrarySchema;       // Indicates library methods are put in seperate schema
        protected MethodsConfig oMethodsConfig;

        public const String PREFIX = "svc";

        public LibraryDescription(MethodsConfig oMethodsConfiguration)
        {
            oMethodsConfig = oMethodsConfiguration;
            oNSManager = new XmlNamespaceManager(new NameTable());
        }

        #region Public Properties
        public String Name
        {
            get { return LibraryName; }
        }

        public String Namespace
        {
            get { return LibraryNS; }
        }

        public XmlNamespaceManager NamespaceManager
        {
            get { return oNSManager; }
        }

        public List<InterfaceDescription> Interfaces
        {
            get { return oInterfaceDescriptions; }
        }

        public string[] XSDNamespaces
        {
            get
            {
                String[] oNamespaces = new string[oNamespacetoXmlSchemaDictionary.Count];
                oNamespacetoXmlSchemaDictionary.Keys.CopyTo(oNamespaces, 0);
                return oNamespaces;
            }
        }
        #endregion

        /// <summary>
        /// Get the path to the XSD file for the schema with target namespace equal to Namespace
        /// </summary>
        public string GetXSDPath(string Namespace)
        {
            if (String.IsNullOrEmpty(Namespace) || !oNamespacetoXSDDictionary.ContainsKey(Namespace))
                return null;

            return oNamespacetoXSDDictionary[Namespace];
        }

        /// <summary>
        /// Get the XmlSchema object for the schema with target namespace equal to Namespace
        /// </summary>
        public XmlSchema GetXmlSchema(string Namespace)
        {
            if (String.IsNullOrEmpty(Namespace) || !oNamespacetoXmlSchemaDictionary.ContainsKey(Namespace))
                return null;

            return oNamespacetoXmlSchemaDictionary[Namespace];
        }

        /// <summary>
        /// Add the library description to the Schema
        /// </summary>
        protected virtual void AddLibraryDescriptionToSchema(XmlSchema oXmlSchema)
        {
            // Check if it already exists
            if (null != XMLHelper.GetElementFromUncompiledSchema(oXmlSchema, LibraryName))
                return;

            // Create the Library complex type
            // <xs:element name="LibrarySchEle">
            //   <xs:complexType>
            //     <xs:sequence>
            //       <xs:sequence>
            //         // Initial Interfaces and Methods
            //       </xs:sequence>
            //       <xs:choice minOccurs="1" maxOccurs="unbounded">
            //         // All Interfaces and Methods
            //       </xs:choice>
            //     </xs:sequence>
            //   </xs:complexType>
            // </xs:element>
            XmlSchemaElement LibrarySchEle = new XmlSchemaElement();
            LibrarySchEle.Name = LibraryName;
            XmlSchemaComplexType complexType = new XmlSchemaComplexType();
            LibrarySchEle.SchemaType = complexType;

            XmlSchemaSequence sequence = new XmlSchemaSequence();
            complexType.Particle = sequence;

            // Just add specified initial Interface and Methods to the xs:sequence
            XmlSchemaSequence InitialInterfaces = new XmlSchemaSequence();
            sequence.Items.Add(InitialInterfaces);

            if ((null != oMethodsConfig) && (null != oMethodsConfig.InitialMethods))
            {
                // For each specified initial interface and method
                for (int j = 0; j < oMethodsConfig.InitialMethods.Length; j++)
                {
                    bool bFoundMethod = false;
                    string oMethodName = oMethodsConfig.InitialMethods[j];
                    // Search each interface
                    for (int i = 0; i < oInterfaceDescriptions.Count; i++)
                    {
                        String InterfaceName = oInterfaceDescriptions[i].Name;
                        // Search each method on that interface
                        for (int k = 0; k < oInterfaceDescriptions[i].Methods.Count; k++)
                        {
                            // Until we find a match
                            MethodDescription oMethodDesc = oInterfaceDescriptions[i].Methods[k];
                            if(oInterfaceDescriptions[i].GetMethodNodeName(oMethodDesc).Equals(oMethodName, StringComparison.CurrentCulture))
                            {
                                // Create the initial method schema element
                                XmlSchema oMethodSchema = oNamespacetoXmlSchemaDictionary[oMethodDesc.InputMessageNamespace];
                                XmlSchemaElement oInitialMethodSchemaElement = oInterfaceDescriptions[i].FindMethodSchemaElement(oMethodSchema, oMethodDesc);
                                if (null == oInitialMethodSchemaElement)
                                    continue;
                                // Add a reference to this XmlSchemaElement
                                XmlSchemaElement oRefMethodSchemaEle = new XmlSchemaElement();
                                oRefMethodSchemaEle.RefName = new XmlQualifiedName(oInitialMethodSchemaElement.Name, (oMethodDesc as WSDLMethodDescription).InputMessageNamespace);
                                InitialInterfaces.Items.Add(oRefMethodSchemaEle);
                                bFoundMethod = true;
                                break;
                            }
                        }
                        if (bFoundMethod)
                            break;
                    }
                    if (!bFoundMethod)
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), "An initial method of '" + oMethodsConfig.InitialMethods[j] +
                            "' was specified but could not be found.  Skipping", Log.LogType.Warning);
                    }
                }
            }

            // Add all Interfaces to the xs:choice particle
            XmlSchemaChoice AllInterfaces = new XmlSchemaChoice();
            AllInterfaces.MinOccurs = 1;
            AllInterfaces.MaxOccursString = "unbounded";
            sequence.Items.Add(AllInterfaces);

            for (int i = 0; i < oInterfaceDescriptions.Count; i++)
            {
                List<XmlSchemaElement> oMethodSchemaEles = oInterfaceDescriptions[i].CreateRefToMethodSchemaElements(oNamespacetoXmlSchemaDictionary);
                for (int j = 0; j < oMethodSchemaEles.Count; j++)
                {
                    AllInterfaces.Items.Add(oMethodSchemaEles[j]);
                }
            }

            // Add the library to the target schema
            oXmlSchema.Items.Add(LibrarySchEle);

            // Add the required namespaces
            if(String.IsNullOrEmpty(oNSManager.LookupPrefix(LibraryNS)))
                oNSManager.AddNamespace(PREFIX, LibraryNS);
            //// If we are building upon an existing schema, keep its target namespace
            //if(bUseSeperateLibrarySchema)
            //    oXmlSchema.TargetNamespace = LibraryNS;

        }

        ///// <summary>
        ///// Construct the name of the XSD file from the LibraryNS and LibraryName and make sure no invalid file name chars are used.
        ///// </summary>
        //public String GetSchemaFilename(String OutputDir)
        //{
        //    return GetFilenameFromSchemaNS(OutputDir, LibraryNS, true);
        //}

        /// <summary>
        /// Convert a schema NS into a filename, but construct the target filename differently
        /// </summary>
        protected String GetFilenameFromSchemaNS(String OutputDir, String SchemaNS, bool IsTargetNS)
        {
            int index = -1;
            String CleanTargetNS = SchemaNS;
            // Pretend the NS is a Uri and try to get the hostname as the NS
            if (IsTargetNS)
            {
                try
                {
                    Uri oNSUri = new Uri(CleanTargetNS, UriKind.RelativeOrAbsolute);
                    if (!String.IsNullOrEmpty(oNSUri.Host))
                        CleanTargetNS = oNSUri.Host;
                    else
                    {
                        // If there is a scheme, get the first segment
                        if (!String.IsNullOrEmpty(oNSUri.Scheme))
                            if ((null != oNSUri.Segments) && (oNSUri.Segments.Length > 0))
                                CleanTargetNS = oNSUri.Segments[0];
                    }
                }
                catch { }
            }
            else
            {
                try
                {
                    Uri oNSUri = new Uri(CleanTargetNS, UriKind.RelativeOrAbsolute);
                    if (!String.IsNullOrEmpty(oNSUri.Host) && (null != oNSUri.AbsolutePath))
                        CleanTargetNS = oNSUri.Host + oNSUri.AbsolutePath;
                }
                catch { }
            }
            // Clean up the NS if necessary
            while (-1 != (index = CleanTargetNS.IndexOfAny(Path.GetInvalidFileNameChars())))
                CleanTargetNS = CleanTargetNS.Replace(CleanTargetNS.ToCharArray()[index], '-');

            if (null == OutputDir)
                OutputDir = "";

            String Filename = Path.Combine(OutputDir, CleanTargetNS + ".xsd");

            if (IsTargetNS)
            {
                String CleanLibraryName = LibraryName;
                // Clean up the Name if necessary
                while (-1 != (index = CleanLibraryName.IndexOfAny(Path.GetInvalidFileNameChars())))
                    CleanLibraryName = CleanLibraryName.Replace(CleanLibraryName.ToCharArray()[index], '-');

                // If the NS and the LibraryName are different, use both.
                if (!SchemaNS.Equals(LibraryName))
                    Filename = Path.Combine(OutputDir, CleanLibraryName + "@" + CleanTargetNS + ".xsd");
            }
            return Filename;
        }
    }
}
