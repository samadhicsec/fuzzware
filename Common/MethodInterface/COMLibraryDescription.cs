using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.XPath;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Web.Services.Description;
using System.Runtime.InteropServices;
using ComTypes = System.Runtime.InteropServices.ComTypes;
using Fuzzware.Common;
using Fuzzware.Common.Interop;
using Fuzzware.Common.XML;
using Fuzzware.Schemas.AutoGenerated;

namespace Fuzzware.Common.MethodInterface
{
    /// <summary>
    /// The purpose of COMLibraryDescription is to create WSDL description of a COM IDispatch interface and any
    /// associated COM IDispatch interfaces.
    /// </summary>
    public class COMLibraryDescription : WSDLLibraryDescription
    {
        Guid CLSID;
        String ProgID;

        public const String COMTransport = "urn:Fuzzware.Common.MethodInterface.COMTransport";

        public COMLibraryDescription(String WSDLOutputPath, Guid ComGuid, String ProgId, MethodsConfig oMethodsConfiguration)
            : base(oMethodsConfiguration)
        {
            CLSID = ComGuid;
            ProgID = ProgId;

            // Create a WSDL file description of the COM interface
            ServiceDescription oServiceDescription = CreateServiceDescription();

            String[] WSDLPathAndFile = new string[1];
            WSDLPathAndFile[0] = Path.Combine(WSDLOutputPath, LibraryNS + ".wsdl");
            oServiceDescription.Write(WSDLPathAndFile[0]);

            LoadWSDL(WSDLPathAndFile, WSDLInputProtocol.Soap12);
        }

        /// <summary>
        /// We override the WSDL one because we need calls to GetMethodNodeName to go to COMInterfaceDescription
        /// </summary>
        protected override void LoadInterfaces(ServiceDescription sd)
        {
            oInterfaceDescriptions = new List<InterfaceDescription>();

            for (int i = 0; i < sd.Services.Count; i++)
            {
                COMInterfaceDescription oWSDLInterfaceDescription = new COMInterfaceDescription(sd.Services[i], m_eProtocol);
                oInterfaceDescriptions.Add(oWSDLInterfaceDescription);
            }
        }

        private ServiceDescription CreateServiceDescription()
        {
            // Set Interface name and namespace
            //GetNameAndNamespace(out LibraryName, out LibraryNS);

            // Get the IDispatch interface
            IDispatch IDispatchObj = GetIDispatch();
            
            // Get the TypeInfo
            ComTypes.ITypeInfo oTypeInfo;
            IDispatchObj.GetTypeInfo(0, 0, out oTypeInfo);
            if (null == oTypeInfo)
                Log.Write(MethodBase.GetCurrentMethod(), "IDispatch.GetTypeInfo returned a null TypeInfo", Log.LogType.Error);
            
            // Get the TypeLib
            ComTypes.ITypeLib oTypeLib;
            int iIndex;
            oTypeInfo.GetContainingTypeLib(out oTypeLib, out iIndex);
            TypeLibHelper oTypeLibHelper = new TypeLibHelper(oTypeLib);
            LibraryNS = oTypeLibHelper.Name;

            //ComTypes.ITypeInfo oLibTypeInfo;
            //int Count = oTypeLib.GetTypeInfoCount();
            //for (int i = 0; i < Count; i++)
            //{
            //    oTypeLib.GetTypeInfo(i, out oLibTypeInfo);
            //    TypeInfoHelper oLibTypeInfoHelper = oTypeLibHelper.AddInterfaceTypeInfo(oLibTypeInfo);
            //}

            // Initialise the TypeInfoHelper
            TypeInfoHelper oTypeInfoHelper = oTypeLibHelper.AddInterfaceTypeInfo(oTypeInfo);
            LibraryName = oTypeInfoHelper.Name;

            // Create the ServiceDescription
            ServiceDescription oServiceDescription = new ServiceDescription();
            oServiceDescription.TargetNamespace = LibraryNS;

            // Create the Type information (XML Schema)
            Types oTypes = new Types();
            XmlSchema oXmlSchema = new XmlSchema();
            oXmlSchema.TargetNamespace = LibraryNS;
            oTypes.Schemas.Add(oXmlSchema);
            // Link Types to ServiceDescription (there is only 1 Types element)
            oServiceDescription.Types = oTypes;

            for (int index = 0; index < oTypeLibHelper.InterfaceTypeInfoHelpers.Count; index++)
            {
                oTypeInfoHelper = oTypeLibHelper.InterfaceTypeInfoHelpers[index];

                // Create the service (wsdl:service)
                Service oService = new Service();
                //oService.Name = oTypeLibHelper.Name + "." + oTypeInfoHelper.Name;
                oService.Name = oTypeInfoHelper.Name;

                // Create the PortType (wsdl:portType)
                PortType oPortType = new PortType();
                oPortType.Name = oTypeInfoHelper.Name;

                // Create the Binding (wsdl:binding)
                Binding oBinding = new Binding();
                oBinding.Name = oTypeInfoHelper.Name;
                oBinding.Type = new XmlQualifiedName(oPortType.Name, LibraryNS);
                // Create the wsdl:binding/soap12:binding
                Soap12Binding oSoap12Binding = new Soap12Binding();
                oSoap12Binding.Style = SoapBindingStyle.Rpc;
                oSoap12Binding.Transport = COMTransport;
                oBinding.Extensions.Add(oSoap12Binding);

                // Create the Port (wsdl:service/wsdl:port)
                Port oPort = new Port();
                oPort.Name = oPortType.Name;
                oPort.Binding = new XmlQualifiedName(oBinding.Name, LibraryNS);
                oService.Ports.Add(oPort);
                // Create Soap Addres (wsdl:service/wsdl:port/soap12:address)
                Soap12AddressBinding oSoap12AddressBinding = new Soap12AddressBinding();
                //oSoap12AddressBinding.Location = CLSID.ToString();
                oSoap12AddressBinding.Location = oTypeInfoHelper.Guid.ToString();
                oPort.Extensions.Add(oSoap12AddressBinding);

                // Link Messages, PortTypes, Bindings and Services to ServiceDescription
                oServiceDescription.PortTypes.Add(oPortType);
                oServiceDescription.Bindings.Add(oBinding);
                oServiceDescription.Services.Add(oService);

                // Add all the operations to the binding
                for (int i = 0; i < oTypeInfoHelper.Functions.Count; i++)
                {
                    // Create new OperationBinding (wsdl:binding/wsdl:operation)
                    OperationBinding oOperationBinding = new OperationBinding();
                    oBinding.Operations.Add(oOperationBinding);
                    Soap12OperationBinding oSoap12OperationBinding = new Soap12OperationBinding();
                    oOperationBinding.Extensions.Add(oSoap12OperationBinding);

                    // Create WSDL Input and Output Bindings
                    // wsdl:binding/wsdl:operation/wsdl:input
                    InputBinding oInputBinding = new InputBinding();
                    oOperationBinding.Input = oInputBinding;
                    // wsdl:binding/wsdl:operation/wsdl:output
                    OutputBinding oOutputBinding = new OutputBinding();
                    oOperationBinding.Output = oOutputBinding;

                    // Create Soap1.2 Body Bindings
                    // wsdl:binding/wsdl:operation/wsdl:input/soap12:body
                    Soap12BodyBinding oInputSoap12BodyBinding = new Soap12BodyBinding();
                    oInputSoap12BodyBinding.Use = SoapBindingUse.Encoded;
                    oInputSoap12BodyBinding.Namespace = LibraryNS;
                    oInputSoap12BodyBinding.Encoding = "http://schemas.xmlsoap.org/soap/encoding/";
                    oInputBinding.Extensions.Add(oInputSoap12BodyBinding);
                    // wsdl:binding/wsdl:operation/wsdl:output/soap12:body
                    Soap12BodyBinding oOutputSoap12BodyBinding = new Soap12BodyBinding();
                    oOutputSoap12BodyBinding.Use = SoapBindingUse.Encoded;
                    oOutputSoap12BodyBinding.Namespace = LibraryNS;
                    oOutputSoap12BodyBinding.Encoding = "http://schemas.xmlsoap.org/soap/encoding/";
                    oOutputBinding.Extensions.Add(oOutputSoap12BodyBinding);

                    // Set the operation binding name
                    oOperationBinding.Name = oTypeInfoHelper.Functions[i].NamePrefix + oTypeInfoHelper.Functions[i].Name;

                    if (String.IsNullOrEmpty(oOperationBinding.Name))
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), "Encountered a function with no name.  Skipping.", Log.LogType.Warning);
                        continue;
                    }

                    // Set the Soap1.2 Operation Binding
                    //oSoap12OperationBinding.SoapAction = LibraryNS + "." + LibraryName + "." + oOperationBinding.Name;
                    oSoap12OperationBinding.SoapAction = oService.Name + "." + oOperationBinding.Name;
                    oSoap12OperationBinding.Style = SoapBindingStyle.Rpc;

                    // Create the input and output message (wsdl:message)
                    Message oInputMessage = new Message();
                    oInputMessage.Name = oPortType.Name + "." + oOperationBinding.Name + "SoapIn";
                    Message oOutputMessage = new Message();
                    oOutputMessage.Name = oPortType.Name + "." + oOperationBinding.Name + "SoapOut";

                    // Set the return type    
                    if (null != oTypeInfoHelper.Functions[i].ReturnParam)
                    {
                        MessagePart oReturnMessagePart = new MessagePart();
                        oReturnMessagePart.Name = oTypeInfoHelper.Functions[i].ReturnParam.ParamName;
                        oReturnMessagePart.Type = oTypeInfoHelper.Functions[i].ReturnParam.AddToSchema(oXmlSchema, oTypeLibHelper);
                        if (!oReturnMessagePart.Type.IsEmpty)
                            oOutputMessage.Parts.Add(oReturnMessagePart);
                    }

                    List<ParamDescHelper> oParameters = oTypeInfoHelper.Functions[i].Parameters;
                    for (int j = 0; j < oParameters.Count; j++)
                    {
                        // Create a MessagePart for this parameter
                        MessagePart oMessagePart = new MessagePart();
                        oMessagePart.Name = oParameters[j].ParamName;

                        // Get the message type
                        oMessagePart.Type = oParameters[j].AddToSchema(oXmlSchema, oTypeLibHelper);
                        // Add the message to the input or output
                        if (oParameters[j].IsOutParam)
                            oOutputMessage.Parts.Add(oMessagePart);
                        else
                            oInputMessage.Parts.Add(oMessagePart);
                    }

                    // Add the messages to the ServiceDescription
                    oServiceDescription.Messages.Add(oInputMessage);
                    oServiceDescription.Messages.Add(oOutputMessage);

                    // Create wsdl:portType/wsdl:operation
                    Operation oOperation = new Operation();
                    oOperation.Name = oOperationBinding.Name;
                    oOperation.ParameterOrder = oTypeInfoHelper.Functions[i].ParameterOrder.ToArray();
                    // Create wsdl:portType/wsdl:operation/wsdl:input
                    OperationInput oOperationInput = new OperationInput();
                    oOperationInput.Message = new XmlQualifiedName(oInputMessage.Name, LibraryNS);
                    oOperation.Messages.Add(oOperationInput);
                    // Create wsdl:portType/wsdl:operation/wsdl:output
                    OperationOutput oOperationOutput = new OperationOutput();
                    oOperationOutput.Message = new XmlQualifiedName(oOutputMessage.Name, LibraryNS);
                    oOperation.Messages.Add(oOperationOutput);
                    // Add operation to the portType
                    oPortType.Operations.Add(oOperation);

                }
            }

            return oServiceDescription;
        }

        /// <summary>
        /// Get the IDispatch interface from the CLSID
        /// </summary>
        private IDispatch GetIDispatch()
        {
            object COMObject = null;
            Type COMType = null;
            try
            {
                // Get a reference to the COM Class Object type
                if (Guid.Empty != CLSID)
                {
                    COMType = System.Type.GetTypeFromCLSID(CLSID, true);
                }
                else if (null != ProgID)
                {
                    COMType = System.Type.GetTypeFromProgID(ProgID, true);
                    CLSID = COMType.GUID;
                }
                // Activator.CreateInstance can reset the current directory
                String CurDir = Environment.CurrentDirectory;

                // Create instance of type so we can query it for its functions
                COMObject = Activator.CreateInstance(COMType);

                Environment.CurrentDirectory = CurDir;
            }
            catch (System.Runtime.InteropServices.COMException eCom)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "A COM error occurred: " + eCom.Message, Log.LogType.Error);
            }
            catch (Exception e)
            {
                Log.Write(e);
            }

            // Make sure we can call IDispatch methods
            if (!(COMObject is IDispatch))
                Log.Write(MethodBase.GetCurrentMethod(), "COM object does not implement IDispatch", Log.LogType.Error);

            // Get the IDispatch interface
            IDispatch IDispatchObj = (IDispatch)COMObject;

            // Check type info count
            int iTypeInfoCount;
            IDispatchObj.GetTypeInfoCount(out iTypeInfoCount);
            if (iTypeInfoCount != 1)
            {
                Log.Write(MethodBase.GetCurrentMethod(), "IDispatch.GetTypeInfoCount() = 0, COM object does not allowing querying of Type information", Log.LogType.Error);
            }

            return IDispatchObj;
        }

        ///// <summary>
        ///// Return the a name and namespace for the COM object
        ///// </summary>
        //private void GetNameAndNamespace(out string sName, out string sNamespace)
        //{
        //    // Get version independent prog id
        //    String VersionIndependentProgID = (String)Microsoft.Win32.Registry.GetValue(@"HKEY_CLASSES_ROOT\CLSID\{" + CLSID + @"}\VersionIndependentProgID", "", null);

        //    if (String.IsNullOrEmpty(VersionIndependentProgID))
        //    {
        //        if (!String.IsNullOrEmpty(ProgID))
        //            VersionIndependentProgID = ProgID;
        //        else
        //        {
        //            VersionIndependentProgID = (String)Microsoft.Win32.Registry.GetValue(@"HKEY_CLASSES_ROOT\CLSID\{" + CLSID + @"}\ProgID", "", null);
        //            if (!String.IsNullOrEmpty(VersionIndependentProgID))
        //            {
        //                bool bRemovedNum = false;
        //                do
        //                {
        //                    bRemovedNum = false;
        //                    // Create version independent version
        //                    int iFinalDot = VersionIndependentProgID.LastIndexOf(".");
        //                    if (iFinalDot > -1)
        //                    {
        //                        // If there is a dot '.', and after the dot is a num, then remove the num
        //                        String Num = VersionIndependentProgID.Substring(iFinalDot + 1, VersionIndependentProgID.Length - (iFinalDot + 1));
        //                        ulong ulNum = 0;
        //                        if (UInt64.TryParse(Num, out ulNum))
        //                        {
        //                            VersionIndependentProgID = VersionIndependentProgID.Substring(0, iFinalDot);
        //                            bRemovedNum = true;
        //                        }
        //                    }
        //                }
        //                while (bRemovedNum);
        //            }
        //            else
        //            {
        //                // TODO: Build our own
        //                VersionIndependentProgID = "UnknownCOMNS.UnknownCOM";
        //            }
        //        }
        //    }

        //    // We have a version independent prog id, so get namespace.name
        //    //int iLastDot = VersionIndependentProgID.LastIndexOf(".");
        //    //if (iLastDot > -1)
        //    //{
        //    //    sName = VersionIndependentProgID.Substring(iLastDot + 1, VersionIndependentProgID.Length - (iLastDot + 1));
        //    //    sNamespace = VersionIndependentProgID.Substring(0, iLastDot);
        //    //}
        //    //else
        //    //{
        //    //    sName = VersionIndependentProgID;
        //    //    sNamespace = VersionIndependentProgID;
        //    //}
        //    sNamespace = VersionIndependentProgID;
        //    sName = "";
        //}

        public Guid ClassID
        {
            get
            {
                return CLSID;
            }
        }
    }
}
