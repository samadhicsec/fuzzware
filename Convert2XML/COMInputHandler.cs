using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.Xml;
using System.Xml.Schema;
using System.Xml.XPath;
using System.Xml.Serialization;
using Fuzzware.Schemas.AutoGenerated;
using Fuzzware.Common;
using Fuzzware.Common.XML;
using Fuzzware.Common.MethodInterface;

namespace Fuzzware.Convert2XML
{
    public class COMInputHandler : InputHandler
    {
        COMInput m_oCOMInput;
        COMLibraryDescription m_oLibrary;
        Guid m_CLSID;
        String m_ProgId;

        XmlDefaultValues oXmlDefaultValues;

        public override void Initialise(object Settings, Encoding OutputEncoding)
        {
            this.OutputEncoding = OutputEncoding;
            if (!(Settings is COMInput))
                Log.Write(MethodInfo.GetCurrentMethod(), "Expected Settings object of type 'COMInput', got '" + Settings.GetType().ToString() + "'", Log.LogType.Error);

            m_oCOMInput = Settings as COMInput;

            if (String.IsNullOrEmpty(m_oCOMInput.OutputDir))
                m_oCOMInput.OutputDir = Environment.CurrentDirectory;

            if (m_oCOMInput.ItemElementName == ItemChoiceType.CLSID)
                m_CLSID = new Guid(m_oCOMInput.Item);
            else if (m_oCOMInput.ItemElementName == ItemChoiceType.ProgId)
                m_ProgId = m_oCOMInput.Item;
            else
                Log.Write(MethodBase.GetCurrentMethod(), "Unknown COM input control identifier type", Log.LogType.Error);
            // TODO: Load tlb from file using
            //[DllImport("oleaut32.dll", CharSet=CharSet.Unicode, PreserveSig=false)]
            //private static extern void LoadTypeLibEx(string strTypeLibName, REGKIND regKind, out ITypeLib TypeLib);
            //internal enum REGKIND
            //{
            //    REGKIND_DEFAULT = 0,
            //    REGKIND_LOAD_TLB_AS_32BIT = 0x20,
            //    REGKIND_LOAD_TLB_AS_64BIT = 0x40,
            //    REGKIND_NONE = 2,
            //    REGKIND_REGISTER = 1
            //}



            // Deserialise the default values
            XmlDefaultValuesLoader oDefValsLoader = new XmlDefaultValuesLoader();
            oXmlDefaultValues = oDefValsLoader.Load(m_oCOMInput.MethodsConfig.DefaultValues);
        }

        public COMInput COMInputSettings
        {
            get
            {
                return m_oCOMInput;
            }
        }

        public Guid ClassID
        {
            get
            {
                return m_CLSID;
            }
        }

        public String ProgID
        {
            get
            {
                return m_ProgId;
            }
        }

        public LibraryDescription Description
        {
            get
            {
                return m_oLibrary as LibraryDescription;
            }
        }

        public override XmlSchemaSet SchemaSet
        {
            get
            {
                if (null == SchemaPaths)
                {
                    // Create the Xml Schema.
                    if(!String.IsNullOrEmpty(m_ProgId))
                        Log.Write(MethodBase.GetCurrentMethod(), "Processing COM interface '" + m_ProgId + "'", Log.LogType.Info);
                    else
                        Log.Write(MethodBase.GetCurrentMethod(), "Processing COM interface '" + m_CLSID.ToString() + "'", Log.LogType.Info);

                    // We always need to create the LibraryDescription
                    String OutputDir = Path.GetFullPath(m_oCOMInput.OutputDir);
                    if (!Directory.Exists(OutputDir))
                        Directory.CreateDirectory(OutputDir);

                    m_oLibrary = new COMLibraryDescription(OutputDir, m_CLSID, m_ProgId, m_oCOMInput.MethodsConfig);

                    if (Guid.Empty == m_CLSID)
                        m_CLSID = m_oLibrary.ClassID;

                    // Get the one namespace that should be referenced
                    string[] SchemaNamespaces = m_oLibrary.XSDNamespaces;
                    SchemaPaths = new string[1];
                    // We possibly don't need to create the description file each time, but it doesn't hurt
                    SchemaPaths[0] = m_oLibrary.GetXSDPath(SchemaNamespaces[0]);

                    if (File.Exists(SchemaPaths[0]))
                    {
                        if (m_oLibrary.IsPreExisting(SchemaNamespaces[0]))
                            Log.Write(MethodBase.GetCurrentMethod(), "Using existing input schema file '" + SchemaPaths[0] + "'", Log.LogType.Info);
                        else
                            Log.Write(MethodBase.GetCurrentMethod(), "Using existing input schema file '" + SchemaPaths[0] + "'.  Delete it and re-run to generate a new one", Log.LogType.Info);
                    }
                    else
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), "Creating input schema file '" + SchemaPaths[0] + "'", Log.LogType.Info);

                        XmlSchema oXmlSchema = m_oLibrary.GetXmlSchema(SchemaNamespaces[0]); ;

                        if (!Directory.Exists(Path.GetDirectoryName(Path.GetFullPath(SchemaPaths[0]))))
                            Directory.CreateDirectory(Path.GetDirectoryName(Path.GetFullPath(SchemaPaths[0])));

                        // Write out the schema
                        using (FileStream fs = new FileStream(SchemaPaths[0], FileMode.Create, FileAccess.Write, FileShare.ReadWrite))
                        {
                            oXmlSchema.Write(fs, m_oLibrary.NamespaceManager);
                        }
                    }
                }

                return base.SchemaSet;
            }
        }

        public override String XMLFilePath
        {
            get
            {
                if (String.IsNullOrEmpty(XMLPath))
                {
                    if (null == m_oLibrary)
                        m_oLibrary = new COMLibraryDescription(Path.GetFullPath(m_oCOMInput.OutputDir), m_CLSID, m_ProgId, m_oCOMInput.MethodsConfig);

                    XMLPath = Path.GetFullPath(Path.Combine(m_oCOMInput.OutputDir, m_oLibrary.Name + "Input.xml"));
                    
                    // If we already have an existing XML file, use that one in case the user has editted it
                    if (File.Exists(XMLPath))
                    //if(false)
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), "Using existing XML file '" + XMLPath + "'.  Delete it and re-run to generate a new one", Log.LogType.Info);
                    }
                    else
                    {
                        Log.Write(MethodBase.GetCurrentMethod(), "Creating XML file '" + XMLPath + "'.", Log.LogType.Info);

                        XMLGenerator oGen = new XMLGenerator(SchemaSet, LibraryDescription.PREFIX, new XmlQualifiedName(m_oLibrary.Name, m_oLibrary.Namespace), m_oLibrary.NamespaceManager, oXmlDefaultValues);
                        XmlDocument oDoc = oGen.Generate();

                        // Randomize the order of the methods called
                        MethodNodeRandomizer oRandomizer = new MethodNodeRandomizer();
                        oDoc = oRandomizer.RandomizeAndFilterMethodCalls(oDoc, m_oCOMInput.MethodsConfig.InitialMethods);

                        XmlWriterSettings oXmlWriterSettings = new XmlWriterSettings();
                        oXmlWriterSettings.Indent = true;
                        XmlWriter oXmlWriter = XmlWriter.Create(XMLPath, oXmlWriterSettings);
                        oDoc.WriteTo(oXmlWriter);
                        oXmlWriter.Flush();
                        oXmlWriter.Close();
                    }
                }
                return XMLPath;
            }
        }

        

        /// <summary>
        /// Returns a new XmlDocument with the method call order randomized
        /// </summary>
        //private XmlDocument RandomizeMethodCalls(XmlDocument oDoc)
        //{
        //    // The array of methods that will be the first used in the script
        //    XPathNavigator[] oInitialMethodCalls = new XPathNavigator[0];
        //    // The list of methods that will be randomly added to the script
        //    List<XPathNavigator> oMethodCalls = new List<XPathNavigator>();

        //    // Get an XPathNav to the library element
        //    XPathNavigator oLibraryNav = XMLHelper.GetRootNode(oDoc);
        //    // Get an XPathNav to the first interface
        //    XPathNavigator oInterfaces = oLibraryNav.Clone();
        //    if (!oInterfaces.MoveToFirstChild())
        //        return oDoc;

        //    //// If the user specified a list of initial methods
        //    //List<COMInputMethodName> InitialMethodList;
        //    //if (null == oCOMInput.InitialMethods)
        //    //    InitialMethodList = new List<COMInputMethodName>();
        //    //else
        //    //{
        //    //    InitialMethodList = new List<COMInputMethodName>(oCOMInput.InitialMethods);
        //    //    oInitialMethodCalls = new XPathNavigator[oCOMInput.InitialMethods.Length];
        //    //}

        //    // Create a list of XPathNavs to all the method calls
        //    do
        //    {
        //        String InterfaceName = oInterfaces.LocalName;
        //        XPathNavigator oMethod = oInterfaces.Clone();
        //        // Move to the first method
        //        if (!oMethod.MoveToFirstChild())
        //            continue;

        //        //int iInitialMethodsFound = 0;   // A count so that we don't check for initial methods after we have found them all
        //        // Loop through all the methods
        //        do
        //        {
        //            String MethodName = oMethod.LocalName;
        //            bool bAlreadyAdded = false;

        //            //// Check if this method is one of the initial methods we need to use
        //            //for (int i = 0; (i < InitialMethodList.Count) && (iInitialMethodsFound < InitialMethodList.Count); i++)
        //            //{
        //            //    if ((!String.IsNullOrEmpty(InitialMethodList[i].OnInterface) &&
        //            //        InterfaceName.Equals(InitialMethodList[i].OnInterface, StringComparison.CurrentCulture)) &&
        //            //        MethodName.Equals(InitialMethodList[i].Value, StringComparison.CurrentCulture))
        //            //    {
        //            //        // If it is, add it to our list of initial methods and increment the number found
        //            //        // Note, we have to add the initial methods in the correct position
        //            //        oInitialMethodCalls[i] = oMethod.Clone();
        //            //        iInitialMethodsFound++;
        //            //        bAlreadyAdded = true;
        //            //        break;
        //            //    }
        //            //}

        //            if(!bAlreadyAdded)
        //                // Otherwise add it to the list of methods that will be added in random order
        //                oMethodCalls.Add(oMethod.Clone());

        //        }
        //        while (oMethod.MoveToNext());

        //    } 
        //    while (oInterfaces.MoveToNext());

        //    //Create new XmlDocument
        //    XmlDocument oRandomDoc = new XmlDocument();

        //    // Add Xml declaration
        //    XmlDeclaration Decl = oRandomDoc.CreateXmlDeclaration("1.0", "utf-8", null);
        //    oRandomDoc.AppendChild(Decl);

        //    XmlElement oLibraryNode = oRandomDoc.CreateElement(oLibraryNav.Prefix, oLibraryNav.LocalName, oLibraryNav.NamespaceURI);

        //    // Initialise PRNG (we want this to generate the same random order each time)
        //    Random oRanGen = new Random(0);

        //    //// Add initial method calls
        //    //for (int i = 0; i < oInitialMethodCalls.Length; i++)
        //    //{
        //    //    if (null == oInitialMethodCalls[i])
        //    //    {
        //    //        Log.Write(MethodBase.GetCurrentMethod(), "An initial method of '" + InitialMethodList[i].Value + "' (on interface '" +
        //    //            InitialMethodList[i].OnInterface + "') was specified but could not be found.  Skipping", Log.LogType.Warning);
        //    //        continue;
        //    //    }

        //    //    XPathNavigator MethodToAdd = oInitialMethodCalls[i];
        //    //    XPathNavigator MethodInterface = MethodToAdd.Clone();
        //    //    MethodInterface.MoveToParent();
        //    //    // Create the interface node
        //    //    XmlElement oInterfaceNode = oRandomDoc.CreateElement(MethodInterface.Prefix, MethodInterface.LocalName, MethodInterface.NamespaceURI);
        //    //    // Add the method to the interface
        //    //    XmlNode oParamNode = oRandomDoc.ImportNode(((IHasXmlNode)MethodToAdd).GetNode(), true);
        //    //    oInterfaceNode.AppendChild(oParamNode);
                
        //    //    // Add interface and method to the library
        //    //    oLibraryNode.AppendChild(oInterfaceNode);
        //    //}

        //    // Add method calls and then remove that method
        //    while (oMethodCalls.Count > 0)
        //    {
        //        int PositionToAdd = oRanGen.Next(oMethodCalls.Count);

        //        XPathNavigator MethodToAdd = oMethodCalls[PositionToAdd];

        //        XPathNavigator MethodInterface = MethodToAdd.Clone();
        //        MethodInterface.MoveToParent();
        //        // Create the interface node
        //        XmlElement oInterfaceNode = oRandomDoc.CreateElement(MethodInterface.Prefix, MethodInterface.LocalName, MethodInterface.NamespaceURI);
        //        // Add the method to the interface
        //        XmlNode oParamNode = oRandomDoc.ImportNode(((IHasXmlNode)MethodToAdd).GetNode(), true);
        //        oInterfaceNode.AppendChild(oParamNode);

        //        // Add interface and method to the library
        //        oLibraryNode.AppendChild(oInterfaceNode);

        //        oMethodCalls.RemoveAt(PositionToAdd);
        //    }

        //    oRandomDoc.AppendChild(oLibraryNode);
        //    return oRandomDoc;
        //}
    }
}
